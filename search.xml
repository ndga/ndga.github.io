<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL-基本操作]]></title>
    <url>%2F2019%2F08%2FMySQL%2FMySQL-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. mysql配置文件 查看MySQL服务的PID 第一种：lsof -i:3306 第二种：cat /var/run/mysqld/mysqld.pid 查看MySQL的错误日志 cat /var/log/mysqld.log 指定文件socket在哪里，登录MySQL mysql -uroot -p&#39;xxx&#39; -S /var/lib/mysql/mysql.sock 123456789101112131415161718192021222324252627282930313233[root@MySQL ~]# cat /etc/my.cnf[mysqld_safe]log-error=/var/log/mysql/mysql.log#这是指定mysql的日志文件的路径#指定mysqld_safe进程的配置#需要在mkdir /var/log/mysql 目录，然后使用命令chown mysql:mysql /var/log/mysql#因为mysql进程需要往/var/log/mysql目录里写东西，需要权限，不然不能往目录下写日志[client]socket=/data/mysql/mysql.sock#对客户端的配置##socket是用来指定socket文件的路径，方便客户端连接找到[mysqld]socket=/data/mysql/mysql.sockport = 3309open_files_limit = 8192innodb_buffer_pool_size = 256M#mysqld是服务器端的配置#port 指定端口号#open_files_limit 指定mysql进程可以打开的文件数量，需要在操作系统里允许进程打开更多的文件#使用ulimit -n 65535#innodb_buffer_pool_size 指定缓存池的大小，提升数据性能的参数，最大可以达到物理内存的80%#破解密码用#user=mysql#skip-grant-tables#指定mysqld的socket文件所在的路径，/data/mysql目录一定要先存在。#指定mysqld进程的配置[mysql]auto-rehashprompt=\\u@\\d \\R:\\m mysql&gt;#对mysql命令执行的配置#auto-rehash 支持tab键补齐#prompt 登录进去后的提示符 [root@MySQL ~]# 2. 进程间通信的方式 socket（套接字） 信号 信号量 消息队列 管道 共享内存 3. socket1. 文件socket mysqld–服务端进程，监听端口：3306 mysql–客户端进程，去连接mysqld，登录mysql服务器 socket文件mysql.sock就是mysql进程与mysqld进程通信的一种方式 实现一台电脑里的不同进程之间通信的文件 1[root@MySQL ~]# mysql -uroot -p'xxx' -S /var/lib/mysql/mysql.sock 在my.cnf配置文件里配置socket=/var/lib/mysql/mysql.sock，在使用mysql客户端命令连接的时候，就不需要接 -S 指定socket文件的路径了 12[root@MySQL ~]# vim /etc/my.cnfsocket=/var/lib/mysql/mysql.sock 2. 网络socket 实现不同电脑之间的不同进程间的通信 ip：端口号，如192.168.0.135:3306 在网络中通过ip地址找到对方 0.0.0.0 本机上任意的ip地址 127.0.0.1 本地的回环测试接口，只能本机自己访问，别的机器不能访问 :::3306 本机上的任意ip地址上开启3306端口 查看别的机器开启了哪些端口，扫描工具nmap 12345678910111213[root@MySQL ~]# nmap 192.168.0.189Starting Nmap 6.40 ( http://nmap.org ) at 2019-08-28 20:47 CSTNmap scan report for 192.168.0.189Host is up (0.00031s latency).Not shown: 997 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http3306/tcp open mysqlMAC Address: 00:0C:29:40:B2:6C (VMware)Nmap done: 1 IP address (1 host up) scanned in 0.18 seconds 在mysql中创建一个用户cali并给他授权 1mysql&gt; grant ALL on *.* to &apos;cali&apos;@&apos;%&apos; identified by &apos;Sanchuang123#&apos;; 在其他电脑上连过来 1[root@MySQL ~]# mysql -h 192.168.0.135 -ucalifeng -p'xxx' 4. Windows的客户端远程连接linux里的mysql的软件 SQLyog 第3方公司产品 workbench mysql官方自己出品 使用SQLyog第1次远程连接的时候，会出现不允许连接，是因为mysql为了安全的考虑，不允许远程登录，如果需要远程登录，就需要给一个用户授权才能远程登录到mysql。 12# 授权root用户可以从任何机器登录到mysql服务器上使用的密码是passwordmysql&gt; grant ALL on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos;; 12# 授权cali用户可以从任何机器登录到mysql服务器上使用的密码是xxxmysql&gt; grant all on *.* to &apos;cali&apos;@&apos;%&apos; identified by &apos;xxx&apos;; grant 是数据库里的授权命令 ALL 是所有的权限（select、update、delete、insert等） on *.* 在所有的库所有的表上（mysql.user：表示mysql数据库里的user表） &#39;root&#39;@&#39;%&#39; 这表示一个用户名是root可以从任何地方登录 identified by &#39;xxx&#39; 指定密码为xxx 5. MySQL中一些基本的操作命令 登录mysql 123[root@MySQL ~]# mysql -uroot -p'xxx'# -uroot 指定登录mysql的用户是root(user)# -p'xxx' 指定登录的密码(password) 显示mysql里所有的数据库 1mysql&gt; show databases; 创建xiongda数据库 1mysql&gt;create database xiongda default charset=utf8; 字符集：数据库默认的字符集是latin1，为了对中文的支持，建议修改为utf8编码 字符集是可以继承的，字段继承表，表继承数据库（数据库–》表–》字段） 使用xiongda这个数据库 1mysql&gt; use xiongda; 显示某个数据库里的所有表 1mysql&gt;show tables; 创建studentinfo这个表 1mysql&gt;create table studentinfo(id int,name varchar(20),sex char(1),age int(3)); 往studentinfo表插入数据 1mysql&gt;insert into studentinfo(id,name,sex,age) values(2,&apos;li&apos;,&apos;男&apos;,23); 查询studentinfo表里的所有数据 1mysql&gt;select * from studentinfo; 让账号过期 1mysql&gt; alter user &apos;cxl&apos;@&apos;localhost&apos; password expire; root用户给其他用户重设密码 1mysql&gt; set password for &apos;cxl&apos;@&apos;localhost&apos; = password(&apos;123&apos;); 查看设置密码的帮助信息 1mysql&gt; help set password; 从user表里查看有哪些用户和主机 1mysql&gt; select user,host from user; 退出MySQL 1mysql&gt; exit 6. 破解MySQL密码的过程 停止mysql服务 1234[root@MySQL ~]# service mysqld stopRedirecting to /bin/systemctl stop mysqld.service[root@MySQL ~]# lsof -i:3306[root@MySQL ~]# 把user=mysql添加到/etc/my.cnf文件里，指定启动MySQL进程的用户 123456789 [root@MySQL ~]# vim /etc/my.cnf [root@MySQL ~]# cat /etc/my.cnf[mysqld]# 把关闭密码复杂性策略给注释掉# validate-password=off# 指定启动MySQL进程的用户user=mysql# 跳过密码验证skip-grant-tables 使用“--skip-grant-tables”参数重新启动mysql，跳过认证 1234567 [root@MySQL ~]# mysqld --skip-grant-tables &amp;[1] 9573[root@MySQL ~]# lsof -i:3306COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld 7122 mysql 32u IPv6 39703 0t0 TCP *:mysql (LISTEN)[1]+ 退出 1 mysqld --skip-grant-tables[root@MySQL ~]# 使用空密码登录mysql 123456789101112131415[root@MySQL ~]# mysql -uroot -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.26 MySQL Community Server (GPL)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; 刷新权限表并重置密码 12345678mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)mysql&gt; set password for &apos;root&apos;@&apos;localhost&apos;=&apos;123456&apos;;Query OK, 0 rows affected (0.00 sec)mysql&gt; exit;Bye 退出后重新修改mysql的配置文件/etc/my.cnf 12345678[root@MySQL ~]# vim /etc/my.cnf[root@MySQL ~]# cat /etc/my.cnf# 关闭密码复杂性策略validate-password=off# 指定启动MySQL进程的用户user=mysql# 把跳过密码验证给注释掉# skip-grant-tables 杀死用“--skip-grant-tables”参数启动的那个mysql进程 123456789[root@MySQL ~]# ps aux|grep mysqldmysql 25648 0.2 9.1 1183152 171180 pts/1 Sl 21:56 0:00 mysql --skip-grant-tablesroot 25684 0.0 0.0 112724 988 pts/1 S+ 21:59 0:00 grep --color=auto mysqld[root@MySQL ~]# kill -9 25648[root@MySQL ~]# lsof -i:3306[1]+ 已杀死 mysqld --skip-grant-tables[root@MySQL ~]# service mysqld restartRedirecting to /bin/systemctl restart mysqld.service[root@MySQL ~]# 用重置的密码登录 12345678910111213141516[root@MySQL ~]# mysql -uroot -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.26 MySQL Community Server (GPL)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; `]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>socket</tag>
        <tag>密码破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL-安装部署]]></title>
    <url>%2F2019%2F08%2FMySQL%2FMySQL-%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[数据库介绍数据库种类：Oracle(大型数据库)、MySQL(中小型数据库)、SQLserver、mariadb、MongoDB、Redis、db2、infomix、达梦、AliSQL、sqlite3(轻量级数据库)等 关系型：Oracle、MySQL、SQLserver、mariadb 非关系型：MongoDB、Redis（key/value） MySQL：开源的数据库，不是免费的数据库软件，有商业版和开源版本（开源版本是免费的），目前属于 Oracle 旗下产品。 Oracle MySQL Cloud Service (commercial) 云服务器版本MySQL Enterprise Edition (commercial) 企业版MySQL Cluster CGE (commercial) 集群版本MySQL Community Edition (GPL) 社区版 –》免费 前提环境 centos6默认的数据库是MySQL，可以直接用 yum install 命令安装 centos7默认的数据库是mariadb，不能再用 yum install 命令安装MySQL 操作环境 一台全新的虚拟机、CentOS 7.6、MySQL的rpm压缩包 mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar（rpm包方式安装）、Xshell 3.0 整个过程中要安装的工具：yum install lrzsz -yyum install vim -yyum install lsof -y 1. 把压缩包从Windows里传到Linux1root@MySQL ~]# rz 在弹出框里找到mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar存放的位置，选择文件 2. 解压安装（rpm包方式安装） 解压缩包 1[root@MySQL ~]# tar xf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar 123456mysql-community-server：是MySQL提供服务功能的软件包mysql-community-client：客户端管理需要的工具mysql-community-libs：库文件 librarymysql-community-devel：开发工具和接口程序 developmentmysql-community-test：测试环境软件mysql-community-embedded：嵌入式相关的软件 安装所有解压出来的软件包 1[root@MySQL ~]# yum install mysql-community* -y 3. 关闭防火墙 数据库服务器一般不启用防火墙，主要是考虑性能的问题。会在数据库服务器的前面加一个防火墙。 关闭防火墙 123456# 关闭firewalld服务，立即生效[root@MySQL ~]# service firewalld stop # 查看防火墙规则[root@MySQL ~]# iptables -L# 清除防火墙规则[root@MySQL ~]# iptables -F 查看默认防火墙状态（关闭后显示not running，开启后显示running） 1[root@MySQL ~]# firewall-cmd --state 4. 关闭selinux selinux的状态分为三种： enforcing（1）：强制模式。违反SELinux规则的行为将被阻止并记录到日志中； permissive（0）：宽容模式。违反SELinux规则的行为只会记录到日志中，一般为调试用； disabled：关闭SELinux； 查看selinux的工作模式 123[root@MySQL ~]# getenforce# 强制模式。违反 SELinux 规则的行为将被阻止并记录到日志中Enforcing 把selinux的工作模式设置为宽容模式 Permissive 12345# 临时设置[root@MySQL ~]# setenforce 0[root@MySQL ~]# getenforce# 宽容模式。违反 SELinux 规则的行为只会记录到日志中。一般为调试用Permissive 123456# 永久设置 # 配置/etc/sysconfig/selinux文件或/etc/selinux/config文件[root@MySQL ~]# vim /etc/sysconfig/selinux # SELINUX=enforcing# 修改状态为disabled，关闭 SELinuxSELINUX=disabled 注意：selinux工作模式可以在文件/etc/sysconfig/selinux中设定。如果想从disabled切换到enforcing或者permissive的话，需要重启系统。反过来也一样。enforcing 和 permissive 模式也可以通过setenforce 1和setenforce 0命令临时切换。 5. 启动MySQL程序 mysqld ==&gt; mysql daemon 守护进程守护进程：不是运行一下，马上就关闭的进程，是一直运行的。因为有人会随时来访问，都可以访问这个进程。 启动mysqld（MySQL安装好后，会自动设置开机启动） 1[root@MySQL ~]# systemctl start mysqld.service 查看MySQL是否已启动的几种方法 查看服务的端口号是否被占用(MySQL默认监听 3306 端口) 123[root@MySQL ~]# lsof -i:3306COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld 23736 mysql 31u IPv6 97567 0t0 TCP *:mysql (LISTEN) 查看进程是否存在 12[root@MySQL ~]# netstat -anplut|grep mysqld tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 23736/mysqld ps -ef查看进程是否存在 123[root@MySQL ~]# ps -ef|grep mysqldmysql 23736 1 0 08:11 ? 00:00:05 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pidroot 24085 24029 0 10:01 pts/0 00:00:00 grep --color=auto mysqld ps aux查看进程是否存在 123[root@MySQL ~]# ps aux|grep mysqldmysql 23736 0.0 9.2 1185516 172696 ? Sl 08:11 0:05 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pidroot 24087 0.0 0.0 112724 984 pts/0 R+ 10:01 0:00 grep --color=auto mysqld 参看mysqld的状态（开启时显示Active: active (running)，关闭时显示Active: inactive (dead)） 1[root@MySQL ~]# service mysqld status 6. 登录MySQL数据库 不能使用空密码进入（mysql命令是用来登录mysql服务器的客户端工具） 1234[root@MySQL ~]# mysql -uroot -pEnter password: ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)[root@MySQL ~]# 在mysql第一次安装好启动的时候，设置了一个临时密码，需要去日志文件里查看 123[root@MySQL ~]# cat /var/log/mysqld.log|egrep "temporary password"2019-08-26T03:12:20.181055Z 1 [Note] A temporary password is generated for root@localhost: T6hqHwx-Mw.p[root@MySQL ~]# 复制密码登入mysql数据库 12345[root@MySQL ~]# mysql -uroot -p'T6hqHwx-Mw.p'mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.26 7. 重新设置密码 进入MySQL数据库后，必须重新设置密码 123mysql&gt; show databases;ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.mysql&gt; 使用alter user重置密码（alter：更改），要满足密码复杂度。如果密码设置太简单，会报错：ERROR 1819 (HY000): Your password does not satisfy the current policy requirements。因为MySQL默认安装了validate_password插件。默认配置下，密码要求至少8位，至少1个数字，1个小写字母，1个大写字母和1个特殊符号 1234mysql&gt; alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;123456&apos;;ERROR 1819 (HY000): Your password does not satisfy the current policy requirementsmysql&gt; alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;Lxd123456.&apos;;Query OK, 0 rows affected (0.00 sec) 设置成功后退出用新密码登录 8. MySQL里设置密码的几种方式 第一种 123mysql&gt; update mysql.user set authentication_string=password(&apos;Lxd123456.&apos;) where user=&apos;root&apos; and host=&apos;localhost&apos;;Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1 第二种 12mysql&gt; set password=&apos;Lxd123456..&apos;;Query OK, 0 rows affected (0.00 sec) 第三种 12mysql&gt; alter user 'root'@'localhost' identified by 'Lxd123456.';Query OK, 0 rows affected (0.00 sec)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机知识]]></title>
    <url>%2F2019%2F08%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1. centos6和centos7的一些区别 数据库 centos6支持mysql，可以直接安装mysql的软件包 1[root@MySQL ~]# yum install mysqld mysqld-server centos7支持的是mariadb，centos7的官方库里已经没有mysql的软件包了 1[root@MySQL ~]# yum install mariadb mariadb-server 防火墙 centos6里默认的防火墙软件 iptables 1234# 临时关闭防火墙[root@MySQL ~]# servcie iptables stop # 永久关闭防火墙 [root@MySQL ~]# chkconfig iptables off centos7里默认的防火墙软件 firewall 1234# 临时关闭防火墙[root@MySQL ~]# systemctl stop firewalld.service # 禁止firewall开机启动[root@MySQL ~]# systemctl disable firewalld.service 管理服务和程序 centos6用 service centos7开始使用 systemctl，包括了service和chkconfig 123456789101112131415启动一个服务：systemctl start firewalld.service 关闭一个服务：systemctl stop firewalld.service 重启一个服务：systemctl restart firewalld.service 显示一个服务的状态：systemctl status firewalld.service 在开机时启用一个服务：systemctl enable firewalld.service 在开机时禁用一个服务：systemctl disable firewalld.service 查看服务是否开机启动：systemctl is-enabled firewalld.service;echo $? 查看已启动的服务列表：systemctl list-unit-files|grep enabled 2. 如何查看本机里哪些服务是开机启动的？12# 查看本机开机的时候，哪些服务是启动的(disabled 不启动，enabled 启动)[root@localhost ~]# systemctl list-unit-files 12# 禁用firewalld服务，开机不启动 ==》下次开机不启动[root@localhost ~]# systemctl disable firewalld 12# 开机启动firewalld服务[root@localhost ~]# systemctl enable firewalld 1234# 这表示mysql是开机启动[root@localhost ~]# systemctl list-unit-files|grep "mysqld"mysqld.service enabled mysqld@.service disabled 3. 虚拟机克隆和快照的区别？ 克隆是形成两个一模一样的虚拟机，不需要重新安装虚拟机 快照是建立一个恢复点（还原点），如果虚拟机出现问题，可以还原到当时的状态（当时保存的某个快照点） 如何克隆？关闭虚拟机 –》 右击虚拟机 –》 点管理 –》 克隆 –》 链接克隆 poweroff：关机reboot：重启init 6 重新启动kill -9 processname/processid：杀死进程，9是一种信号 4. 新装的虚拟机用不了ifconfig命令怎么办？1[root@MySQL ~]# yum provides ifconfig 1[root@MySQL ~]# yum search ifconfig 1[root@MySQL ~]# yum search all ifconfig 123456789[root@MySQL ~]# yum search ifconfig已加载插件：fastestmirrorLoading mirror speeds from cached hostfile * base: mirrors.cqu.edu.cn * extras: mirrors.cqu.edu.cn * updates: mirrors.aliyun.com======================== 匹配：ifconfig =========================net-tools.x86_64 : Basic networking tools[root@MySQL ~]# yum install net-tools 5. 解决从Windows里传文件到Linux的问题 点击xshell上方的菜单栏里的New File Transfer，然后拖动文件到相应文件夹 用rz命令打开一个对话框，选择要传送的文件 6. yum安装和编译安装的区别 源码编译安装 –》企业里使用最多方式 可以开启很多功能 可以指定安装路径 –》最大的好处，因为MySQL需要存放数据，需要大量的磁盘空间，企业里会单独给MySQL一个存放数据的地方。 yum安装 –》 方便 yum安装和编译安装的区别 专卖店 买衣服 –》yum 裁缝店 定制衣服 –》编译安装]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
        <tag>零碎知识</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django-CSRF]]></title>
    <url>%2F2019%2F08%2FDjango%2FDjango-CSRF%2F</url>
    <content type="text"><![CDATA[1. 什么是CSRF？CSRF：跨站请求伪造（Cross-site request forgery），也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。【来自百度百科】 可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括： 以你名义发送邮件，发消息，盗取你的账号 甚至于购买商品，虚拟货币转账…… 造成的问题包括：个人隐私泄露以及财产安全。 2. CSRF的原理下图简单阐述了CSRF攻击的思想： 从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤： 登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。=&gt; host/trans/from=a&amp;to=bsite&amp;money=100 看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生： 你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。 你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……） 上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。 CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！ 3. 对CSRF的防御CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。服务端的CSRF防御方法有很多，但总的思想都是一致的，就是在客户端页面增加伪随机数。 Cookie Hashing 所有表单都包含同一个伪随机值。这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了。这个方法已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。 One-Time Tokens 不同的表单包含一个不同的伪随机值。每个伪随机数只使用一次。这也是Django使用的方法。但是在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提 交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单 都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。 4. Django应对CSRF攻击的办法 原理 Django使用专门的中间件CsrfMiddleware来进行CSRF防护。具体的原理如下： Django第一次响应来自某个客户端的请求时，会在服务器端随机生成一个token，把这个token放在cookie里。然后每次 POST 请求都会带上这个token，这样就能避免被 CSRF 攻击。 在返回的 HTTP 响应的cookie里，Django会为你添加一个csrftoken字段，其值为一个自动生成的token 在所有的 POST 表单提交时，必须包含一个csrfmiddlewaretoken字段 （只需要在模板里加一个 模板标签， Django就会自动帮你生成） 在处理 POST 请求之前，Django会验证这个请求的cookie里的csrftoken字段的值和提交的表单里的csrfmiddlewaretoken字段的值是否一样。如果一样，则表明这是一个合法的请求，否则，这个请求可能是来自于别人的 csrf 攻击，返回 403 Forbidden. 在所有ajax POST 请求里，添加一个RequestHeader X-CSRFTOKEN，其值为cookie里的csrftoken字段的值 具体操作 settings.py配置（全局防护）12345678910# 配置中间件,启用django.middleware.csrf.CsrfViewMiddleware# 加上后即可全局使用csrf防护（默认已经添加）；MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', ...] 注：该中间件必须在`SessionMiddleware`之后。它也必须在响应被压缩或解压之前对响应结果进行处理，因此`CsrfMiddleware`必须在`GZipMiddleware`之后执行。 局部防护方法：在视图函数上加@csrf_protect进行单view控制 12from django.views.decorators.csrf import csrf_protect# 对应的函数加 @csrf_protect 装饰器 局部不防护：在视图函数中不想进行csrf保护的view可以加上@csrf_exempt 12from django.views.decorators.csrf import csrf_exempt# 对应的函数加 @csrf_exempt 装饰器 启用全局防护时 HTML 页面中 form表单 的操作 1 在HTML的表单中form标签后加上{% csrf_token %}123456- 启用全局防护时 ajax 提交 Post 请求操作 - 视图使用render返回 - 在html模板`script`标签中加： $.ajaxSetup({ data: {csrfmiddlewaretoken: &apos;{{ csrf_token }}&apos; }, }); 1注：不能`.js`文件中加这个代码 12345678910111213### 5. 其它模板引擎&gt; 如与Jinja2结合的解决办法：1、`settings.py`配置- 在`MIDDLEWARE_CLASSES`中加上`django.middleware.csrf.CsrfViewMiddleware'`这个中间件2、校验cookie中的csrf值- 视图函数：导入模块 from django.core.context_processors import csrf 1234567- 修改上下文参数 ```python context = &#123;&#125; context.update(csrf(request)) return render(context, 'login.html') 在模板HTML文件中的对应的Form表单里加 1&lt;input type="hidden" id="csrfmiddlewaretoken" name="csrfmiddlewaretoken" value="&#123;&#123; csrf_token &#125;&#125;"&gt;]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django-Rides缓存]]></title>
    <url>%2F2019%2F08%2FDjango%2FDjango-Rides%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[Redis的安装与配置 查看文档 什么是Redis Redis是一个开源的使用C语言编写的开源免费的，遵守BSD协议，是一个高性能的键值数据库。是当前最热门的NoSql数据库之一，也被人们称为数据结构服务器。 Redis以内存作为数据存储介质，所以读写数据的效率极高，远远超过数据库。以设置和获取一个256字节字符串为例，官方号称它的读取速度可高达110000次/s，并发写速度高达81000次/s。 Redis的好处 运行在内存，速度快。 数据虽在内存，但是提供了持久化的支持，即可以将内存中的数据异步写入到硬盘中，同时不影响继续提供服务 支持数据结构丰富（string（字符串），list（链表），set（集合），zset（sorted set - 有序集合））和Hash（哈希类型，md5加密出来的那个串） Redis的使用场景 数据需要高速访问（内存） 临时存储数据，数据一定时间都不会变（缓存） 我们的验证码，需要保存300s就自动过期。 统计各种不同类型数据器数量，一般来说除了新采购机器会变，平时都不会变，这类查询可以将结果放入redis缓存几小时。 安装Redis yum install redis 配置文件：/etc/redis.conf 默认端口：6379 配置文件：/etc/redis.conf 1234# bind 192.168.123.91 127.0.0.1 ::1 # 指定在几个ip地址上提供服务bind 0.0.0.0# requirepass rootroot # 指定密码（如果配置了密码，那么连接的时候，需要指定密码）port 6379 # 指定端口号 管理Redis服务 12345678# 重启service redis restart# 停止服务service redis stop# 启动服务service redis start# 指定配置文件启动redis-server /etc/redis.conf 检查Redis服务是否启动 123456# 查看redis运行状态service redis status# 检查进程ps aux|grep redis# 检查端口lsof -i:6379 连接Redis服务 1234567891011121314151617181920212223242526272829redis-cli -h 127.0.0.1 -p 6379-h host 主机-p 使用的端口 port-a 指定密码# redis-cli -h 192.168.123.91 -p 6379192.168.123.91:6379&gt; 192.168.123.91:6379&gt; keys * (error) NOAUTH Authentication required.192.168.123.91:6379&gt; auth rootroot #手动的输入密码OK192.168.123.91:6379&gt; # redis-cli -h 192.168.123.91 -p 6379 -a rootroot192.168.123.91:6379&gt; keys *(empty list or set)192.168.123.91:6379&gt;192.168.123.91:6379&gt; set name cali 插入一台key/value数据 name 是key cali 是valueOK192.168.123.91:6379&gt; keys *1) "name"192.168.123.91:6379&gt; set teacher liu OK192.168.123.91:6379&gt; keys * #查询列出所有的keys1) "teacher"2) "name"192.168.123.91:6379&gt; get teacher #查询teacher的value"liu"192.168.123.91:6379&gt; 连接不上的常见问题 检查目标主机是否可连接 ping ip 看是不是通的 进程和监听端口 0.0.0.0:6379 192.168.0.83:6379 127.0.0.1:6379 123lsofpsnetstat 检查iptables 12iptables -nvL # 查看规则iptables -F # 清除防火墙规则 检查selinux 123# 查看selinuc状态[root@redis~]$ getenforceDisabled 应用层白/黑名单 4. Django使用Redis缓存 django-redis文档 安装django-redis pip install django-redis settings配置CACHES：project/settings.py 123456789101112131415161718CACHES = &#123; 'default': &#123; # BACKEND配置缓存后端为RedisCache 'BACKEND': 'django_redis.cache.RedisCache', # LOCATION配置redis服务器地址 'LOCATION': 'redis://127.0.0.1:6379', "OPTIONS": &#123; "CLIENT_CLASS": "django_redis.client.DefaultClient", # 密码：如果redis有密码，记得写上去 "PASSWORD": "", &#125;, &#125;,&#125;# # 以下配置可参考，在settings自定义配置项，方便统一管理# REDIS_TIMEOUT=7*24*60*60# CUBES_REDIS_TIMEOUT=60*60# NEVER_REDIS_TIMEOUT=365*24*60*60]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django-Form表单]]></title>
    <url>%2F2019%2F08%2FDjango%2FDjango-Form%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[1. 什么是Form表单 HTML上展示的用来给用户提交信息的表单 2. 表单使用流程 表单展示 数据提交 数据验证（前端验证和后端验证） 用户名长度 邮箱格式 3. Django-Form表单的作用 前端验证（js验证）： buttom.onclick(function{}) =&gt; 验证 光靠前端验证是不可靠的，因为前端页面是可以被篡改的 后端验证 使用Django-Form表单验证 防止有人篡改前端页面躲开验证 4. Django-Form表单的优劣 好处： 提供后端验证 写起来简单，前端小白的福音 可以直接基于Model来写，易维护 不足： 不够灵活（相对于熟悉前端的人来说） 5. Django中Forms的实现方式 众所周知，form最常做的是对用户输入的内容进行验证，为此django的forms类提供了全面的内容验证和保留用户上次输入数据的支持。django框架提供了一个form类，来处理web开发中的表单相关事项。 Django处理表单中涉及的工作的三个不同部分： 准备和重组数据以使其为渲染做好准备 为数据创建HTML表单 接收和处理客户提交的表格和数据 Form类描述一个表单并确定它是如何工作和出现的。类似于模型类的字段映射到数据库字段的方式，表单类的字段映射到HTML表单&lt;input&gt;元素。 表单的字段本身就是类; 他们管理表单数据并在提交表单时执行验证。不同的字段处理的内容不一样。 Django中提供了两种常用的Form类，分别是forms.ModelForm与forms.Form 如果要将表单中的数据写入数据库或者修改某些记录的值，就要让表单类继承ModelForm，如：class RegisterForm(forms.ModelForm)。ModelForm直接使用Model中的字段创建表单，只需要在表单类中指定使用哪个Model即可。 如果提交表单后不会对数据库进行修改，则继承Form类。自己在表单类中定义字段来创建表单。]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>form表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAT-SNAT-DNAT]]></title>
    <url>%2F2019%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FNAT-SNAT-DNAT%2F</url>
    <content type="text"><![CDATA[NATNAT：网络地址转换（Network Address Translation） 优点 节约公网的IP地址（费用） 能够有效地避免来自外网的攻击，隐藏并保护内网的计算机（外网的人不知道内网的IP地址） 缺点 数据会有延迟 IP地址 A类IP地址范围：1.0.0.1 — 126.255.255.254（127.0.0.1 为保留地址，一般用于本地环回地址） loopback：指本地环回接口（或地址），亦称回送地址 私有地址包括三类 A类：10.0.0.0~10.255.255.255 B类：172.16.0.0~172.31.255.255 C类：192.168.0.0~192.168.255.255 某台机器上配置的 ip 地址为 192.168.0.180，访问 127.0.0.1 的 80 端口和访问 192.168.0.180 的 80 端口有什么区别？ 127.0.0.1:80 只能允许本机去访问，其他机器访问不了 192.168.0.180:80 能被整个 192.168.0.0 网段或者路由能到达的机器访问 0.0.0.0到底什么意思？ 代表本机上有的所有 ip 地址（所有接口上配置的 ip 地址） Linux 内核里有个 NAT 映射表： 源ip：源端口 目的ip：目的端口 源mac地址 映射：即访问一个A 然后转到D去，如：A —&gt; DB —&gt; C有个一一对应的关系，有2边的阵容，访问一般的A，会给你转到另外一边的D。 SNATSNAT：源地址转换（Source Network Address Translation），修改数据包的源 IP 地址。 SNAT的作用 局域网多个主机共享单个公网IP地址接入互联网，让局域网的机器上网，局域网内全部使用私有网络IP地址，可节省公网的IP地址。 把局域网的IP地址转化成公网的IP地址去访问外网，这样返回的响应报文中目的地址会是找得到的公网IP地址，外面的人不知道局域网内的IP地址，起到隐藏内网的作用。 SNAT策略的应用 准备两台centos7.6的虚拟机，一台充当内网主机，IP地址为192.168.57.1。一台充当NAT Server，内网接口的IP地址是192.168.57.2，外网接口的IP地址是192.168.0.156。 1. 配置两台主机的IP地址、子网掩码和默认网关地址 临时配置IP地址（重启失效）ip address add 192.168.57.1/24 dev ens33 配置ip地址ip add del 192.168.57.1/24 dev ens33 删除ip地址 永久配置IP地址、子网掩码和默认网关地址 123456789101112[root@MySQL network-scripts]# cat ifcfg-ens33# BOOTPROTO=dhcpBOOTPROTO=noneNAME=ens33# UUID=655909bd-e927-49a5-88f0-4aeb333409d4DEVICE=ens33ONBOOT=yesIPADDR=192.168.57.1PREFIX=24GATEWAY=192.168.57.2DNS1=114.114.114.114[root@MySQL network-scripts]# service network restart ifcfg-ens33是一个配置文件，Linux下一切皆文件，文件是放在磁盘里的，能被保存下来；而内存里的东西关机后不会被保存。 重新配置 ip 地址后（service network restart）的问题？ ifup ens33 就是去读取网卡配置文件里的 ip 地址，配置到电脑上 ifdown ens33 关闭网卡 service network restart 先关闭网卡，再去读取网卡配置文件里的 ip 地址，配置到电脑上service network restart =&gt; 先 ifdown ens33 再 ifup ens33 2. 清除两台主机的防火墙规则 centos7里默认的防火墙软件 firewallcentos6里默认的防火墙软件 iptables 清除防火墙规则systemctl stop firewalld 关闭firewalld服务iptables -F 清除filter表里的规则iptables -t nat -F 清除nat表里的规则 查看防火墙规则iptables -L 查看filter表里的规则iptables -t nat -L 查看nat表里的规则iptables -t nat -L -nv 以数字形式查看nat表的防火墙规则 3. 开启NAT_Server主机的路由转发功能 临时开启路由功能（重启失效，刷新网络服务也会导致路由功能关闭）echo 1 &gt;/proc/sys/net/ipv4/ip_forward 永久开启路由功能修改/etc/sysctl.conf文件 123[root@NAT_Server ~]# vim /etc/sysctl.conf[root@NAT_Server ~]# cat /etc/sysctl.confnet.ipv4.ip_forward=1 sysctl -p 让内核重新读取文件，配置开启路由功能 123[root@NAT_Server ~]# sysctl -p[root@NAT_Server ~]# cat /proc/sys/net/ipv4/ip_forward1 4. 添加使用SNAT策略的防火墙规则 规则示例iptables -t nat -A POSTROUTING -o ens37 -s 192.168.57.0/24 -j SNAT --to-source 192.168.0.156 解释iptables -t nat -A POSTROUTING 在nat表的POSTROUTING链上添加规则-o ens37 指定数据出去的接口为ens37（o：output）-s 192.168.57.0/24 指定来自特定网段 192.168.57.0/24 的数据包（s：source）-j SNAT 采取的 nat 措施是SNAT策略--to-source 192.168.0.156 指定接入公网时源IP地址改为192.168.0.156 5. 直接在防火墙的服务器编写配置NAT的脚本文件123456789101112131415[root@NAT_Server ~]# vim nat.sh[root@NAT_Server ~]# cat nat.sh #!/bin/bash# 清除nat和filter表里的防火墙规则iptables -t nat -Fiptables -F# 临时开启路由功能echo 1 &gt;/proc/sys/net/ipv4/ip_forward# 添加SNAT功能的防火墙规则iptables -t nat -A POSTROUTING -o ens37 -s 192.168.57.0/24 -j SNAT --to-source 192.168.0.156[root@NAT_Server ~]# bash nat.bash 6. 排除故障思路 检查ip地址、网关、dns是否正确 cat /etc/sysconfig/network-scripts/ifcfg-ens33 检查防火墙是否已关闭 iptables -L 检查路由器的路由功能是否已开启 cat /proc/sys/net/ipv4/ip_forward(0是关闭，1是开启) 检查snat策略是否已启用 iptables -t nat -L -nv 检查路由器本身是否可以上网 ping www.baidu.com 查看正在使用的ip地址 ip add或者ifconfig 查看配置的路由 ip route 查看真正使用的dns服务器地址 cat /etc/resolv.conf 临时关闭NetworkManager systemctl stop NetworkManager 如果有想开机自动执行的命令可以放到 /etc/rc.local 文件下 DNATDNAT：目标地址转换（Destinatvion Network Address Translation），修改数据包的目标IP地址 DNAT的作用 在公网上发布位于局域网内的服务器，把局域网的IP地址转换成公网上能找到的公网IP地址，让公网的用户可以直接访问。 外面的人不知道内网的服务器的IP地址，保护服务器免受黑客攻击 DNAT策略的应用-发布内网的Linux服务器 前提两台主机都配置好了IP地址、关闭了防火墙功能，NAT_Server主机已开启了路由转发功能，如果没有参考前面实现 内网主机环境需要下载有web服务器软件，web服务器软件比较。这里选择Nginx，Nginx是一个加载静态页面的网站，小巧且高效，并发性强，可以做高效的负载均衡反向代理 1. 内网主机开启web服务器 安装epel源 yum install epel-release 安装web服务器-nginx软件包 yum install nginx 刷新nginx服务 service nginx restart 2. 查看服务是否开启 查看nginx服务是否开启 netstat -anplut|grep nginx 安装lsof软件包 yum install lsof查看80端口被哪个进程占用 lsof -i:80 3. 解决访问防火墙服务器本身的问题 方法一：修改ssh服务器的端口，把ssh服务的端口号改成其他的端口号vim /etc/ssh/sshd_config 方法二：修改DNAT策略iptables -t nat -A PREROUTING -i ens37 -d 192.168.0.156 -p tcp --dport 9988 -j DNAT --to-destination 192.168.57.1:22 4. 添加使用DNAT策略的防火墙规则 规则示例iptables -t nat -A PREROUTING -i ens37 -d 192.168.0.156 -p tcp --dport 80 -j DNAT --to-destination 192.168.57.1:80 解释iptables -t nat -A PREROUTING 在nat表的PREROUTING链上添加规则-i ens37 指定数据进来的接口为ens37（i：input）-d 192.168.0.156 指定访问的目的地址是外网ip为192.168.0.156（d：destination）-p tcp --dport 80 指定访问的端口是80端口，在传输层使用的协议是tcp协议（p：protocol）-j DNAT 采取的nat措施是DNAT策略--to-destination 192.168.57.1:80 指定转发到内网的目的IP是192.168.57.1并且端口也是80（端口号也是可以变的，不用跟外网的端口号对应，可以是别的端口号） 5. 直接在服务器上编写配置NAT的脚本文件123456789101112131415161718192021[root@MySQL ~]# vim nat.sh[root@MySQL ~]# cat nat.sh #!/bin/bash# 清除nat和filter表里的防火墙规则iptables -t nat -Fiptables -F# 临时开启路由功能echo 1 &gt;/proc/sys/net/ipv4/ip_forward# 添加SNAT功能的防火墙规则iptables -t nat -A POSTROUTING -o ens37 -s 192.168.57.0/24 -j SNAT --to-source 192.168.0.156# 添加web服务器的DNAT规则iptables -t nat -A PREROUTING -i ens37 -d 192.168.0.156 -p tcp --dport 80 -j DNAT --to-destination 192.168.57.1:80# 添加ssh服务器的DNAT规则iptables -t nat -A PREROUTING -i ens37 -d 192.168.0.156 -p tcp --dport 22 -j DNAT --to-destination 192.168.57.1:22[root@MySQL ~]# bash nat.bash DNAT策略成功后我们就可以通过访问192.168.0.156的IP地址访问到内网主机192.168.57.1的服务器 6. 一些常见服务的端口号 Web服务(nginx/apache)：80 SSH：22 MySQL：3306 SQLServer：1433 Oracle：1521 FTP：21 Tomcat：8080 Telnet ：23 HTTP：80 HTTPS：443]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>SNAT</tag>
        <tag>DNAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django-模型层-基本介绍]]></title>
    <url>%2F2019%2F08%2FDjango%2F%E6%A8%A1%E5%9E%8B%E5%B1%82%2FDjango-%E6%A8%A1%E5%9E%8B%E5%B1%82-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1. 使用db.conn的缺点 需要自己定义模块 每次都需要做连接 数据库迁移麻烦（Oracle迁移到MySQL） 2. ORMORM：对象关系映射（Object Relation Mapping） ORM 是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。ORM 主要实现程序对象到关系数据库数据的映射。优点： 方便数据库迁移 提高开发效率，不用专注于数据库及SQL 返回的数据格式很友好queryset[&lt;username=admin, password=1111&gt;, &lt;&gt;] 缺点： 性能没有原生语句好（本质上所有的ORM语句最终都是执行SQL） 灵活性较差，处理复杂查询时，ORM会很复杂 3. Model介绍 环境说明： * Django==1.11.20 * Python==3.7 1. 可连接不同数据库 支持的数据库&#39;django.db.backends.postgresql&#39;&#39;django.db.backends.mysql&#39;&#39;django.db.backends.sqlite3&#39;&#39;django.db.backends.oracle&#39; 如：在项目的settings.py文件中配置mysql 12345678910111213DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'filepath', 'USER': 'root', 'PASSWORD': 'xxx', 'HOST': 'xxx.xxx.xxx.xxx', 'PORT': '3306', 'OPTIONS': &#123; 'init_command': "SET sql_mode='STRICT_TRANS_TABLES'", &#125;, &#125;&#125; 如：在项目的settings.py文件中配置sqlite3 123456DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125; 2. 字段命名的限制 字段的名称不能是Python保留的关键字。例如： 12pass = models.IntegerField() # 'pass' is a reserved word! 由于Django查询语法的工作方式，字段名称中连续的下划线不能超过一个。例如： 12foo__bar = models.IntegerField() # 'foo__bar' has two underscores! 这些限制有变通的方法，因为没有要求字段名称必须与数据库的列名匹配。参见 db_column 选项。SQL的保留字例如 join、where 和 select，可以用作模型的字段名，因为 Django 会对底层的 SQL 查询语句中的数据库表名和列名进行转义。它根据你的数据库引擎使用不同的引用语法。 3. 配置日志记录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# mysite/settings.py# 定义并创建目录LOG_PATH = os.path.join(BASE_DIR, 'log')if not os.path.exists(LOG_PATH): os.mkdir(LOG_PATH) LOGGING = &#123; 'version': 1, 'disable_existing_loggers': True, # formatters：配置日志格式 'formatters': &#123; 'standard': &#123; 'format': '%(asctime)s [%(threadName)s:%(thread)d] [%(name)s:%(lineno)d] [%(module)s:%(funcName)s] [%(levelname)s]- %(message)s' &#125;, # 对日志信息进行格式化，每个字段对应了日志格式中的一个字段，更多字段参考官网文档 'myformat':&#123; 'format': '%(asctime)s %(pathname)s - %(message)s' &#125; &#125;, # handlers： 配置日志记录到哪里 'handlers': &#123; 'default': &#123; 'level':'DEBUG', 'class':'logging.handlers.RotatingFileHandler', # 'filename': LOG_PATH+'/all.log', # 日志输出文件 'filename': os.path.join(LOG_PATH, 'all.log'), # 日志输出文件 'maxBytes': 1024*1024*5, # 文件大小 'backupCount': 5, # 备份份数 'formatter':'standard', # 使用哪种formatters日志格式 &#125;, 'app1': &#123; 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', 'filename': LOG_PATH + '/app1.log', # 日志输出文件 'maxBytes': 1024 * 1024 * 5, # 文件大小 'backupCount': 5, # 备份份数 'formatter': 'myformat', # 使用哪种formatters日志格式 &#125;, 'console':&#123; 'level': 'DEBUG', 'class': 'logging.StreamHandler', 'formatter': 'standard' &#125;, &#125;, # loggers: 定义记录器，供程序调用 'loggers': &#123; # 名为django的logger会自动记录，其他需要自己调用 'django': &#123; 'handlers': ['default','console'], 'level': 'DEBUG', 'propagate': True &#125; &#125;&#125; 4. 模型定义 每个模型都是django.db.models.Model的一个Python子类。 模型的每个属性都表示为数据库中的一个字段，即映射到一个数据库的列。 Django提供一套自动生成的用于数据库访问的API；详见执行查询。 官方文档 models.py 编写示例123456789101112131415161718192021from django.db import modelsfrom django.contrib.auth.models import User# Create your models here.# 分类表class Category(models.Model): # 定义字段 name = models.CharField(max_length=30, verbose_name="分类名称") desc = models.CharField(max_length=255, default=None, verbose_name="分类描述") index = models.IntegerField(default=999, verbose_name='分类的排序') # 设置元数据（设置查询和展示的输出） class Meta: verbose_name = '分类' verbose_name_plural = verbose_name ordering = ['index', 'id'] db_table = "category" # 类的魔术方法，返回一个友好的显示 def __str__(self): return self.name 5. 同步到数据库 在虚拟环境下执行同步命令 生成迁移文件（变更数据结构）python manage.py makemigrations 生成的迁移文件在该应用的 migrations 目录（以dddd_changecontext.py命名） 查看更新的SQL语句 python manage.py sqlmigrate appname 0001 应用迁移文件到数据库 python manage.py migrate 把迁移文件生成sql语句 在数据里面执行sql语句 在django_migrations表中记录哪些迁移文件被执行过。 注意：migrations 目录下的文件不能随意删除。通过测试发现，检测 Model 变化是与该目录下文件做对比，因此该目录下内容不能随意删除。 6. 数据备份-导入导出 导入：python manage.py loaddata data/initdata/xxx.json 导出：python manage.py dumpdata model_query &gt; data/initdata/mod el_query.json 7. 注意事项 表名这个表的名称AppName_ClassName，是根据模型中的元数据自动生成的，也可以重写为别的名称，详见Table names。 id 字段如果一个 Model 里面没有设置主键，Django 会自动增加一个名为 id 的自增型字段。但这个行为可以被重写。详见自增主键字段。Django的表里面不可以没有主键，但是可以不设置 id 为主键。 SQL语句来源Django 会根据设置文件中指定的数据库类型来使用相应的SQL语句 定义完模型字段后，只要对模型做了修改，都需要执行python manage.py makemigrations和python manage.py migrate 回滚 删除生成的表/字段 删除django_migrations表中对应的记录 删除迁移文件 建议：数据备份，不建议：删库操作]]></content>
      <categories>
        <category>Django</category>
        <category>模型层</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django-开发环境搭建]]></title>
    <url>%2F2019%2F07%2FDjango%2FDjango-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[在GitHub上创建一个仓库​ 登录 GitHub 后，点击 Repositories ，再点 new 新建仓库，如图配置： ​ 在 GitHub 上创建一个仓库，是为了后期可以把所有代码都上传到这个仓库里。Git是一个分布式版本控制工具，可以记录每次修改的文件及修改的内容，使用Git可以很好的给代码做备份，防止丢失，还能给出备份的时间节点以及不同备份间的区别，方便我们管理版本。当我们想查看某次改动的内容，只需要看提交的备注信息就能找到当时的提交文件，还可以进行回滚，获取当时的版本，适合多人协作。 Django-开发环境搭建1. 环境说明 Windows Python3.7 Django1.11.20 SQLLite PyCharm Git 2. 搭建流程 克隆远程仓库到本地仓库，进入 master 分支 $ git clone https://github.com/ndga/Django_study.git $ cd Django_study/ 进入本地仓库 $ git init 初始化本地仓库 （或者直接手动进入本地仓库文件夹里面，右击打开 Git Bash Here，进入 master 分支） 基于 master 分支新建一个分支并切换到新建的分支 $ git branch 列出本地分支 $ git branch -a 列出所有分支 方法一 $ git branch v0.1-django-start 创建v0.1-django-start分支 $ git checkout v0.1-django-start 切换到 v0.1-django-start 分支 方法二 $ git checkout -b v0.1-django-start 创建并切换到 v0.1-django-start 分支 在 v0.1-django-start 分支下配置好虚拟环境 $ python -V 查看 python 的版本 $ python -m venv venv 创建虚拟环境，名为 venv $ source venv/Scripts/activate 进入 venv/Scripts/ 文件夹下并启动虚拟环境 $ pip list 查看虚拟环境里的安装包，如果安装包只有这几个基本上是成功了 1234567891011李@DESKTOP-6SPHB1I MINGW64 /f/Django_study (v0.1-django-start)$ pip listPackage Version---------- -------pip 19.0.3setuptools 40.8.0You are using pip version 19.0.3, however version 19.1.1 is available.You should consider upgrading via the 'python -m pip install --upgrade pip' command.(start_venv)李@DESKTOP-6SPHB1I MINGW64 /f/Django_study (v0.1-django-start)$ $ pip install django==1.11.20 安装 1.11.20 版本的 Django $ pip freeze &gt; requirements.txt 把所有要安装的安装包写入到 requirements.txt 这个文件（这样别人要用的时候就知道该安装什么） $ deactivate 退出虚拟环境 修改 .gitignore 文件 .idea/ =&gt; 使用pycharm会生成的文件，push 到 GitHub 上时需要忽略 venv/ =&gt; 虚拟环境的文件，也需要忽略 把改动提交到仓库 $ git status 查看状态 $ git add requirements.txt 添加 requirements.txt 文件到暂存库 $ git add .gitignore 添加 .gitignore 文件到暂存库 $ git commit -m &#39;env init&#39; 将暂存库的内容提交到版本库，每次提交都必须将提交的注释加上 $ git push --set-upstream origin v0.1-django-start 第一次推送 v0.1-django-start 分支以及里面的内容到远程仓库，之后只要 git push 就可以了 已经把不需要的文件推送到远程仓库怎么办 先把需要忽略的文件移到另外一个文件（相当于给文件改个名字） $ mv filename1 /filename2 把 filename1 和 filename2 都加到 .gitignore 文件里 提交一次（$ git add .， $ git commit -m&#39;xx&#39;，$ git push） 再把文件移回来 mv /filename2 filename1 重新提交一次（$ git add .， $ git commit -m&#39;xx&#39;，$ git push） Django-项目与应用创建1. 常用命令 django-admin：常用来创建项目及应用 123456789101112131415161718192021222324252627Type 'django-admin help &lt;subcommand&gt;' for help on a specific subcommand.Available subcommands:[django]checkcompilemessagescreatecachetabledbshelldiffsettingsdumpdataflushinspectdbloaddatamakemessagesmakemigrationsmigraterunserversendtestemailshellshowmigrationssqlflushsqlmigratesqlsequenceresetsquashmigrationsstartappstartprojecttesttestserver manage.py：常用来管理项目，如运行开发环境，数据库操作，用户操作等，python manage.py help查看帮助文档 12345678910111213141516171819202122232425262728293031323334353637Type 'manage.py help &lt;subcommand&gt;' for help on a specific subcommand.Available subcommands:[auth] changepassword createsuperuser[contenttypes] remove_stale_contenttypes[django] check compilemessages createcachetable dbshell diffsettings dumpdata flush inspectdb loaddata makemessages makemigrations migrate sendtestemail shell showmigrations sqlflush sqlmigrate sqlsequencereset squashmigrations startapp startproject test testserver[sessions] clearsessions[staticfiles] collectstatic findstatic runserver 2. 创建项目和应用 创建项目 $ django-admin startproject projectname 创建应用 $ cd projectname/ $ django-admin startapp appname 注意：每次只要新建了app应用，就要在settings.py文件中的INSTALL_APP里加上app的名字 用 PyCharm 打开项目（选择到项目根目录-mysite） 设置解释器为虚拟环境里的解释器（去虚拟环境的文件夹下找，选择到python.exe） 3. 目录结构12345678910111213141516171819Django_study |_.git # 配置、版本历史等等... |_.gitignore # 忽略某些文件（不检查这些文件的变化、不上传git仓库） |_README.md |_venv # 虚拟环境（文件夹名称随意），不加入git仓库 |_mysite # 项目名称 |_mysite | |_settings.py # 项目的配置文件 | |_urls.py # 编写路由，与视图映射 | |_wsgi.py # 接口文件，用来做部署，不需要修改 | |_... # 如（__init__.py：初始化文件） |_manage.py # 管理项目的文件 |_app1 # 应用名称 |_migrations # 迁移文件 |_admin.py # 后台文件，强大的超级管理员 |_apps.py # 应用的配置文件 |_models.py # 模型，配置与数据库相关的内容 |_tests.py # 写测试用例的文件 |_views.py # 视图，负责业务逻辑]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django-初认识]]></title>
    <url>%2F2019%2F07%2FDjango%2FDjango-%E5%88%9D%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Python Web框架介绍1. 什么是框架web 框架（web framework）是用于进行 web 开发应用的一套软件架构，有助于我们把程序的整体架构搭建好，基于 web 框架实现业务逻辑，减少了工作量，能够让我们专注于 web 应用上有趣的关键性逻辑 , web 框架能够在合适的时候调用我们写的逻辑, 而不需要我们自己去调用逻辑。 2. Web框架有哪些Django: 重量级的Web框架，功能丰富，灵活性差 Flask: 轻量级的Web框架，可扩展性强 Tornado: 轻量级的异步Web框架 Django介绍1. Django的历史 源自于一个在线新闻Web站点，于2005年以开源的形式被释放出来。 官网：https://www.djangoproject.com/ 2. Django的特点 主要目的是简便、快速地开发数据库驱动的网站 功能丰富：自带ORM、URL分发、模板系统、表单处理、Cache系统、会话管理、国际化、后台管理 可扩展：pypi及git上有很多基于Django开发的应用 3. Django的优势和劣势 Django优势 完美的文档 全套的解决方案 强大的URL路由配置 自助管理后台 Django劣势 系统紧耦合，灵活性差 请求响应流程1. MVC模式 模型(M)： 定义数据库相关的内容，负责业务对象与数据库的映射(ORM) 视图(V)： 定义HTML等静态网页文件相关，负责与用户的交互(页面) 控制器(C)： 定义业务逻辑相关，就是你的主要代码，负责接受用户的输入调用模型和视图完成用户的请求 2. Django的MTV模式 M 代表模型（Model）：负责业务对象和数据库的关系映射(ORM)（如何存取，如何验证有效性，包含哪些行为以及数据之间的关系等） T 代表模板 (Template)：负责如何把页面展示给用户(html) V 代表视图（View）：负责业务逻辑，并在适当时候调用Model和Template 3. MVC/MVT设计模式关键的优势 开发者更改一个应用程序中的 URL 而不用影响到这个程序底层的实现 设计师可以改变 HTML页面的样式而不用接触业务逻辑代码 数据库管理员可以重新命名数据表并且只需更改模型 4. 请求响应流程图（简版） 5. 请求响应流程图（复杂版） ​ 前面的图片展示了从一个访客的浏览器到Django应用并返回的一个web请求的简单历程。如下是数字标识的路径： 浏览器发送请求（基本上是字节类型的字符串）到web服务器 web服务器（比如，Nginx）把这个请求转交到一个WSGI（比如，uWSGI），或者直接地文件系统能够取出 一个文件（比如，一个CSS文件） 不像web服务器那样，WSGI服务器可以直接运行Python应用。请求生成一个被称为environ的Ptyhon字典， 而且，可以选择传递过去几个中间件的层，最终，达到Django应用 URLconf中含有属于应用的urls.py选择一个视图处理基于请求的URL的那个请求，这个请求就已经变成了 HttpRequest——一个Python字典对象 被选择的那个视图通常要做下面所列出的一件或者更多件事情： A. 通过模型与数据库对话 B. 使用模板渲染HTML或者任何格式化过的响应 C. 返回一个纯文本响应（不被显示的） D. 抛出一个异常 HttpResponse对象离开Django后，被渲染为一个字符串 在浏览器见到一个美化的，渲染后的web页面]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2019%2F06%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[1. 什么是HTTP协议？HTTP：超文本传输协议（Hyper Text Transfer Protocol）HTTP协议是用于从万维网（WWW：World Wide Web ）服务器传输超文本到本地浏览器的传送协议，规定了服务器和本地浏览器之间如何通信以及通信所使用的数据格式。服务器 –&gt; 超文本传输协议 –&gt; 浏览器（客户端，如：电脑、手机、平板）。HTTP通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 2. 什么是超文本(Hyper Text)？包含有超链接(Link)和各种多媒体元素标记(Markup)的文本。这些超文本文件彼此链接，形成网状(Web)，因此又被称为网页(Web Page)。这些链接使用URL表示。最常见的超文本格式是超文本标记语言HTML。 3. 什么是URL？URL：统一资源定位符（Uniform Resource Locator），用来唯一地标识万维网中的某一个文档。URL由三部分构成：协议、主机域名和端口、文件路径。如图： 4. HTTP协议属于哪层协议？应用层协议：HTTP、HTTPS、FTP、SMTP、SNMP 5. 哪些软件能读懂HTTP协议？提供Web服务的软件都能读懂HTTP协议； 常见的web服务器软件：nginx、apache、tomcat、IIS、lighttpd、django、flask等 web服务器软件比较 常见浏览器：chrome、firefox、curl、requests等 6. HTTP协议采用什么结构？C/S结构（客户/服务器） 客户—Browser：请求、接收、展示Web对象 服务器—Web Server：响应客户的请求，发送对象 7. HTTP协议有哪两种报文？ 请求报文 –&gt; request，请求消息由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 响应报文 –&gt; response，响应消息由状态行、消息报头、空行和响应正文四个部分组成。 8. HTTP的连接方式和无状态性 非持久性连接（短连接） 浏览器每请求一个Web文档，就创建一个新的连接，当文档传输完毕后，连接就立刻被释放。如果请求的Web页中包含多个文档链接，请求每个链接对应的文档都要创建新连接，效率低下。HTTP1.0、HTTP0.9采用此连接方式。 持久性连接（长连接） 在一个连接中，可以进行多次文档的请求和响应。服务器在发送完响应后，并不立即释放连接，浏览器可以使用该连接继续请求其他文档。连接保持的时间可以由双方进行协商（keepalive_timeout：表示传送完最后一个响应之后的连接保持时间的一个参数）。HTTP1.1采用此连接方式。 无状态性 指同一个客户端第二次访问同一个Web服务器上的页面时，服务器无法知道这个客户曾经访问过。HTTP是无状态协议，协议本身并不会保存用户的任何信息，每次请求都是独立的（服务器不维护任何有关客户端过去所发请求的消息）。HTTP的无状态性简化了服务器的设计，可以减小服务器的压力，使其更容易支持大量并发的HTTP请求。 9. HTTP协议的版本比较，现在使用的是什么版本？ 版本 产生时间 内容 情况 HTTP0.9 1991年 不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求，非持久性连接(短连接) 没有作为正式的标准 HTTP1.0 1996年 传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令，非持久性连接(短连接) 正式作为标准 HTTP1.1 1997年 持久性连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码 用了比较久的时间，2015年之前使用的最广泛的版本 HTTP2.0 2015年 多路复用、服务器推送、消息头压缩、二进制格式等 比较新的版本 10. HTTP协议的 1.1 和 2.0 有什么区别？ 数据格式 HTTP 1.1采用的是文本格式。 HTTP 2.0采用的是二进制格式。 消息头压缩 HTTP 1.1不支持header数据的压缩。 HTTP 2.0使用HPACK算法对header的数据进行压缩，这样数据量小，网络传输时间相对短一些。 多路复用 HTTP 1.1默认是持久性连接，所以不用频繁地去创建连接，但是在连接中的多个请求还是会顺序处理，所以一旦有一个请求处理很久的话，后面的请求就会被阻塞。 HTTP 2.0解决了HTTP 1.1中长连接遇到阻塞的问题。它采用多路复用的方式，同一个连接可以并发处理多个请求，同时处理多个消息的请求和响应，而且并发请求的数量比HTTP 1.1大了好几个数量级。 11. 在浏览器里输入https://www.baidu.com ，一个回车后，浏览器里会显示百度的首页，请详细说下背后发生了什么，越细致越好？ 浏览器从URL中获取域名www.baidu.com （如果有端口号，将端口号也解析出来）； 把主机名解析成对应的 IP 地址 浏览器首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 IP 地址； 如果本地的 hosts 文件没有该域名对应的 IP 地址，浏览器会向本地DNS服务器发出查询请求（属于递归查询），本地DNS服务器会查询它的缓存记录，如果有直接返回结果。（如果是首次，由于没有DNS服务器的MAC地址，所以只需要将数据发送给网关路由器192.168.0.1（通过ARP获取其MAC地址），他会想办法发给DNS服务器） 如果本地DNS服务器没有该域名对应的 IP 地址，就需要它代替浏览器给它的上级服务器发送查询请求（属于迭代查询），直到本地DNS服务器得到 IP 地址，返回给浏览器。 浏览器得到 IP 地址后，与服务器通过Socket三次握手建立TCP连接(默认端口号443) 客户端首先向服务器发送一个带有SYN 标识和一个seq的随机数。 服务端收到后，需要给客户端回应一个ack，ack的值就是刚才的seq随机数的值+1，在回应包里，还包含一个SYN的标识和一个seq随机数。 客户端收到服务端发过来的回应包之后，再给服务端发送一个ack,ack的值就是刚才服务端发过来的seq的值+1，三次握手完成。 浏览器向服务器发起HTTP请求，请求百度首页 客户端发送请求头信息，请求内容，最后会发送一空白行，标示客户端请求完毕 服务器通过HTTP响应把首页文件发送给浏览器 浏览器与服务器四次挥手，关闭TCP连接 首先客户端会发送一个带有FIN标识和一个seq随机数。 服务端收到之后，会回应一个ack，ack的值等于刚才的seq的值+1。 发送之后，服务器会再发一个FIN包，这个包里面包含一个seq随机数和第二次返回到客户端的ack值。 客户端收到之后，回应一个ack，ack的值等于刚才的seq值+1，以上完成之后，服务器和客户端的四次挥手就完成了。 浏览器将首页文件进行渲染，将html代码呈现出图片和文字、声音、视频等特效，显示给用户。 12. DNS 递归查询和迭代查询的区别？DNS：域名系统（Domain Name System）域名解析服务器 客户机和本地域名服务器之间一般是递归查询。当客户机向本地域名服务器发出 DNS 查询请求后，不管本地域名服务器能不能解析，最后都是由本地域名服务器把得到的结果返回给客户机。（就好比小明向李老师问了一个问题，李老师告诉了他答案，这就是递归查询。） 本地域名服务器和其他域名服务器之间一般是迭代查询。如果本地域名服务器不能解析，它不会让客户机向其他域名服务器发出查询请求，而是自己代客户机向其他域名服务器发出查询请求。在本地域名服务器向根域名服务器发出查询请求时，如果根域名服务器也不能解析，这时根域名服务器不会代本地域名服务器向顶级域名服务器发出查询请求，而是把顶级域名服务器的 IP 地址返回给本地域名服务器，本地域名服务器再向顶级域名服务器发出查询请求，直到得出结果。（就好比李老师也不知道答案，然后李老师去找陈老师，但是陈老师也不会，就让李老师去问张老师，直到李老师问到了答案，然后李老师再告诉小明，在李老师问其他老师时就是迭代查询。） 13. HTTP协议有哪几种请求方法？根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。 序号 方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于GET请求，只不过返回的响应中没有具体的内容，可以在不返回整个响应内容的情况下获取消息报头。 3 POST 向指定的资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新资源的建立或已有资源的修改。 4 PUT 从客户端向服务器传送最新的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP 1.1协议中预留给能够将连接改为管道方式（把请求连接转换到透明的 TCP/IP 通道）的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能，返回服务器支持的 HTTP 方法。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 14. GET和POST的区别？来自W3school：http://www.w3school.com.cn/tags/html_ref_httpmethods.asp GET POST 后退按钮/刷新 无害。幂等操作，即使刷新也还是跟原来一样。 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。如果往数据库里插入了一条数据，刷新后可能会再次插入。 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 有限制。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 没有限制。所以POST传输的数据量更大。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是显示在 URL 中的，明文传输。在发送密码或其他敏感信息时绝不要使用 GET ！ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中，对用户是透明的。 速度 快。GET 无实体主体，数据都在 URL 中，所以只需要三次握手2个 RTT。 慢。POST 先发送头部信息，再发送数据，相当于三次握手2个 RTT 和发送数据（实体主体）的1个 RTT。 15. 一些常见的响应码/状态码（HTTP Status Code）HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。完整的响应码可以查看原文：https://www.runoob.com/http/http-status-codes.html，HTTP状态码共分为5种类型： 1**：信息，服务器收到请求，需要请求者继续执行操作 100：Continue，继续。客户端应继续其请求。 101：Switching Protocols，切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，如切换到HTTP的新版本协议。 2**：成功，操作被成功接收并处理 200：OK，访问成功。服务器正常响应了请求。 201：Created，已创建。成功请求并创建了新的资源。 202：Accepted，已接收。已经接受请求，但未处理完。 3**：重定向，需要进一步的操作以完成请求 301：Moved Permanently，永久移动。网页位置发生变化。 302：Found，临时移动。资源只是临时被移动，还是在原来的网页位置。 304：Not Modified，网页没刷新 –&gt; 按Ctrl+F5，强制刷新网页内容（不从缓存里读取网页内容）。 4**：客户端错误，请求包含语法错误或无法完成请求 400：Bad Request，客户端请求的语法错误，服务器无法理解。 403：Forbidden，服务器理解客户端的请求，但是设置了权限，拒绝了用户的访问请求。 404：Not Found，网页不存在。 5** 服务器的内部问题，服务器在处理请求的过程中发生了错误 500：Internal Server Error，服务器内部错误，无法完成请求。 501：Not Implemented，服务器不支持请求的功能，无法完成请求。 502：Bad Gateway，网关错误，充当网关或代理的服务器在尝试执行请求时，从远程服务器接收到了一个无效的响应。 504：Gateway Time-out，充当网关或代理的服务器，未及时从远端服务器获取请求。 505：HTTP Version not supported，服务器不支持请求的HTTP协议的版本，无法完成处理。 16. HTTP协议和HTTPS协议的区别？ HTTP协议 HTTPS协议 默认端口 80 443 信息传输方式 超文本传输协议，信明文传输 SSL加密的超文本传输协议，密文传输 安全性 运行在TCP之上的HTTP协议 运行在 SSL/TLS 之上的HTTP协议，是可进行加密传输、身份认证的网络协议， 比HTTP协议更安全 17. HTTPS协议的实现原理（加密原理）？ 客户端向服务器发送HTTPS请求，就是用户在浏览器里输入一个https网址，然后连接到服务器的443端口。 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对非对称密钥（公钥和私钥），服务器把公钥返回给客户端，私钥自己保留。 服务器传送证书给客户端，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。 客户端得到证书后解析证书，这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值（随机的密钥）。客户端用证书对该随机值进行加密，即通过公钥对密钥加密（非对称加密）。 客户端传送用证书加密后的密钥给服务器，服务器收到密钥，用自己的私钥对其进行解密拿到对称密钥，再用对称密钥解密拿到数据，以后客户端和服务器的通信就可以通过这个随机值来进行加密解密（随机值用的是对称加密）。加密的数据只有客户端和服务器才能得到明文，即使第三方拿到了加密后的数据，因为没有私钥，也无法获取到真实的数据。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>网络知识</tag>
        <tag>http协议</tag>
        <tag>nginx配置</tag>
        <tag>抓包工具的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周刷题-20190320]]></title>
    <url>%2F2019%2F06%2FPython%2F%E6%AF%8F%E5%91%A8%E5%88%B7%E9%A2%98-20190320%2F</url>
    <content type="text"><![CDATA[1. Python和Java、PHP、C、C#、C++等其他语言的对比？​ C、C++、C# 都是编译性语言，必须编译后才能执行，而Python是一门解释型的动态类型的语言。在Python中，对象是通过引用传递的，编写代码时不需要声明变量类型，直接给变量赋值即可。Python是一边编译一边执行的，所以相较于C语言和Java来说运行速度会比较慢，但肉眼几乎感知不到，而且Python的语法非常简洁，大大提高编写效率。Python本身就是由C语言开发出来的，而且是开源的。PHP语言主要适用于网页编辑，而Python适合与各个领域。 Java：具有卓越的通用性、高效性、平台移植性和安全性，容易学，学精难，工具丰富 ，大多数人在用。缺点：运行速度相对于C/C++有些缓慢了，这是机制原因导致的。适用于网页、企业级开发、普通应用软件、游戏后台。 PHP：跨平台，性能优越；语法简单，入门快；目前主流技术都支持；有比较完整的支持；有很多成熟的框架；PHP 5已经有成熟的面向对象体系，能够适应基本的面向对象要求；有成熟的社区来支持PHP的开发；目前已经很多大型应用都是使用PHP；有很多开源的框架或开源的系统可以使用；配置及部署相对简单一些。缺点：多线程支持不太好，大多数时候我们只能简单的模拟去实现的；对语法不太严谨；PHP的解释运行机制繁琐。适用于网络前端，用于生成网页。也可以整个web服务器都用php，比如很多论坛引擎。 C：简洁紧凑、灵活方便；运算符丰富；数据类型丰富；表达方式灵活实用；允许直接访问物理地址，对硬件进行操作；生成目标代码质量高，程序执行效率高；可移植性好；表达力强；缺点：C语言的缺点主要表现在数据的封装性上，这一点使得C在数据的安全性上有很大缺陷，这也是C和C++的一大区别。还有运算符和运算优先级过多，不便于记忆，语法定义不严格，编程自由度大，对新手不太友好。适用于系统底层, 驱动, 嵌入式开发。 C#：用C# 开发应用软件可以大大缩短开发周期，同时可以利用原来除用户界面代码之外的C++代码，相比java，有更先进的语法体系、强大的周边。缺点：没有考虑代码量。 C++：可扩展性、高效简洁快速、可移植性、面向对象的特性、强大而灵活的表达能力和不输于C的效率、支持硬件开发、程序模块间的关系更为简单，程序模块的独立性、数据的安全性就有了良好的保障、通过继承与多态性，可以大大提高程序的可重用性，使得软件的开发和维护都更为方便，适用于游戏开发, 大规模, 高性能, 分布式要求的程序开发。 Python的特点： ​ √优雅、明确、简单​ √解释型语言​ √开发效率非常高​ √高级语言​ √可移植性​ √可扩展性​ √可嵌入性 Python的不足之处： ​ √运行速度慢​ √代码不能加密​ √多线程不能利用多CPU问题 2. 简述解释型和编译型编程语言计算机是不能理解高级语言的，更不能直接执行高级语言，它只能理解机器语言，所以任何使用高级语言编写的程序若想被计算机执行，都必须将其转换成机器语言。从而产生了两种转换方式：解释和编译，所以高级语言也分为了解释型语言和编译型语言。 （1）解释型语言的源代码不是直接翻译成机器语言，而是先翻译成中间代码，在程序运行的时候再由解释器把中间代码翻译成机器语言，解释型语言每执行一次就要翻译一次，效率比较低。比如Python、JavaScript、Perl、Shell等。 ​ （2）编译型语言在程序运行之前需要一个专门的编译过程，把源代码编译成可执行的机器语言文件，等程序运行时，直接执行这个文件，可重复使用，不需要每次都翻译一遍，程序执行效率高，但依赖编译器，跨平台性差些。比如C、C++、Delphi等。 3. 代码中要修改不可变数据会出现什么问题，抛出什么异常？​ 报错，抛出TypeError异常。不可变数据类型包括 int、float、string(字符串)、tuple(元组)。可变数据类型包括 list(列表)、dict(字典)、set(集合)。 4. print 调用 Python 中底层的什么方法？​ 在 python2 中，print 是一个命令；在 python3 中，print 是一个函数，print() 调用 sys.stdout.write() 实现，往控制台打印字符串。但是 print() 跟 sys.stdout.write() 还是有点区别，print() 能自动换行，sys.stdout.write() 不能自动换行。print() 能接收多个参数输出，sys.stdout.write() 只能接收一个参数。另外，sys.stdout.write() 只接收字符串格式的参数。 123456789# python2中，两种方式print 'hello world'# hello worldprint('hello world')# hello world# python3中，一种方式print('hello world')# hello world 5. 简述你对 input() 函数的理解 在 python3 中，是内建函数，不需要导入。input(xxx)，输入的内容 xxx 会显示出来，而且 input() 接收的所有数据都是字符串类型。 在 python2 中，分为 input() 和 raw_input()，input() 接收 int（整型）类型的数据；raw_input() 接收 str（字符串）类型的数据。 6. Python解释器种类以及特点 CPython：用 C 语言开发的，是使用最广的 Python 解释器，在命令行下运行 Python 就是启动 CPython 解释器； IPython：基于 CPython 之上的一个交互式解释器，相较于 CPython，只是在交互方式上有所增强； Jpython：运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行； PyPy：用 Python 开发的，对 Python 代码进行动态编译（注意不是解释），所以可以显著提高 Python 代码的执行速度； IronPython：用 C# 开发的，是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码； 7. Python2 中 range 和 xrange 的区别​ 两者用法大致相同，不同的是 range 返回的结果是一个列表，而 xrange 返回的结果是一个生成器。range 是直接开辟一块内存空间来存放列表，xrange 不会直接生成一个列表来占用内存空间，而是在被调用的时候才返回其中的值，是惰性求值。所以当一个列表很大时，用 xrange 可以减少服务器的压力，xrange 性能比 range 好。 12345678&gt;&gt;&gt; print(type(range(10)))&lt;type 'list'&gt;&gt;&gt;&gt; print(type(xrange(10)))&lt;type 'xrange'&gt;&gt;&gt;&gt; print(range(10))[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; print(xrange(10))xrange(10) 8. 位和字节的关系？ 8 位（bit）= 1 字节（Byte） 位 (b) =&gt; 二进制位（0 或 1），是最小数据单位。 字节 (B) =&gt; 存储空间的基本计量单位，基本上1byte 存1个英文字母，2个byte存一个汉字。 9. b、B、KB、MB、GB 的关系？ 1 GB = 1024 MB 1 MB = 1024 KB 1 KB = 1024 B 1 B = 8 bit 10. 请至少列举5个 PEP8 规范（越多越好） 缩进：使用4个空格的缩进，不要使用制表符（Tab键），禁止空格与Tab键混用。 换行：折行以确保其不会超过79个字符。这有助于小显示器用户阅读，也可以让大显示器能并排显示几个代码文件。 空行：使用空行分隔函数和类，以及函数内的大块代码。顶级函数间空2行，类的方法之间空1行，同一函数内的逻辑块之间空1行，文件结尾空一行。 注释：如果可能，注释独占一行。避免逐行添加注释，避免没有一个注释。 空格：运算符周围和逗号后面使用空格，但是括号里侧不加空格，如：a = f(1, 2) + g(3, 4)。 导入格式：每个导入独占一行，导入放在文件顶部，位于模块注释和文档字符串之后，模块全局变量和常量之前。导入应该按照从最通用到最不通用的顺序分组（标准库 -&gt; 第三方库 -&gt; 自定义库），每种分组中, 应该根据每个模块的完整包路径按字典序排序，忽略大小写。不要使用 from xxx import * 这种语法。 变量命名：尽可能的使用有意义的变量名，词能达意。下划线命名法和驼峰命名法。包名、模块名、函数名、方法、普通变量名全部使用小写，单词间用下划线连接。类名、异常名使用 首字母大写（CapWords ） 的方式, 异常名结尾加 Error 或 Wraning 后缀。自定义的变量名、函数名不能和标准库中的函数名重名。 私有变量：小写和一个前导下划线（如：_value）。 内置变量：小写，两个前导下划线和两个后置下划线（如：init）。 11. python递归的最大层数？递归函数停止的条件？​ 可以通过 sys.setrecursionlimit() 进行设置，但是一般默认不会超过3925-3929这个范围。递归函数停止的条件一般定义在递归函数内部，在递归调用前要做一个条件判断，根据判断的结果选择是继续调用自身，还是 return 返回，停止递归。递归函数停止的条件： 判断递归的次数是否达到某一限定值 判断运算的结果是否达到某个范围等，根据设计的目的来选择 12. ASCII、GBK、Unicode、UTF-8的区别？ ASCII：计算机来源于美国，在计算机内部，所有信息最终都表示为二进制的字符串。每一个二进制位(bit)只有0和1两种状态，将8个二进制位看作一组，也就是一个字节(8bit=1byte)。8个二进制位可以组合出256种状态，即一个字节能够表示 256 个数字，数据范围是 0-255。ASCII码一共规定了128个字符的编码，一个字节代表一个字符，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。它的范围基本只有英文字母、数字和一些特殊符号 。 GBK：随着计算机在世界各地的普及，并且不是所有国家都使用英文，中国为了用字节编码汉字，就产生了GB2312。GB2312是对ASCII码的中文扩展，而GBK编码是对GB2312的扩展，完全兼容GB2312，GBK全称《汉字内码扩展规范》，使用双字节码。 Unicode：又称万国码，将世界上所有的符号都纳入其中，每一种符号都给予独一无二的编码，防止乱码。当时很多国家都弄了自己的一套编码标准，结果互相看不懂，有时候因为一个程序就要装一个编码系统，所以为了解决这个问题，就产生了Unicode，统一标准。 UTF-8：变长码，UTF-8是在互联网中使用最多的对Unicode的实现方式。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 13. 字节码和机器码的区别？ 字节码：一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码。 机器码：是计算机可以直接执行，并且执行速度最快的代码。 14. 三元运算规则以及应用场景？​ 三元运算符就是在给变量赋值的时候，可以直接加判断，然后赋值。三元运算符的功能与 if…else 流程语句一致，它在一行中书写，代码非常精炼，执行效率更高。 语法格式：变量 = 值1 if 条件表达式 else 值2（当条件表达式为True时，返回结果为值1，否则返回结果为值2，如：c = a if a &lt; b else b） 15. 列举 Python2和Python3的区别？ print 语句 在 python2 中，print 是一个命令语句，不论想输出什么，直接放到 print 关键字后面即可，如：print “内容”。 在 python3 中，print() 是一个函数，像其他函数一样，print() 需要你将要输出的东西作为参数传给它，如：print(“内容”)。 Unicode 字符串 在 python2 中，默认使用 ASCII 编码，导致字符串有两种类型，Unicode 字符串和非 Unicode 字符串。 在 python3 中，默认使用 Unicode 编码，所以只有一种类型，即 Unicode 字符串。 input 语句 在 python2 中，分为 input() 和 raw_input()，input() 接收 int 型(整型)的数据，raw_input() 接收 str 型(字符串类型)的数据。 在 python3 中，input() 是内建函数，不需要导入，input() 接收的所有数据都会变成字符串类型。 整型 在 python2 中，区分整型、长整型。 整型(int)：在32位机器上，整数的位数为32位，取值范围为-2^312^31-1，即-21474836482147483647。在64位系统上，整数的位数为64位，取值范围为-2^632^63-1，即-92233720368547758089223372036854775807。 长整型(long)：跟C语言不同，python的长整数没有指定位宽，即python没有限制长整数数值的大小，但实际上由于机器内存有限，我们使用的长整数数值不可能无限大。自从python2.2起，如果整数发生溢出，python会自动将整数数据转换为长整数，所以如今在长整数数据后面不加字母L也不会导致严重后果了。 在 python3 中，统称为整型(int)，可存超长数据。 整除 在 python2 中，键入的任何不带小数的数字，将被视为整数的编程类型，如：5/2=2，解决方法：5.0/2.0=2.5。 在 python3 中，整数除法变得更直观，5/2=2.5。 xrange 在 python2 中，range 函数生成的是一个列表，xrange 函数生成的是一个生成器。 在 python3 中，range 函数生成的是一个可迭代对象，并且不再有 xrange 函数存在，使用 xrange 会抛出命名异常。 类 在 python2 中，存在经典类和新式类的区别。新式类要求都从 object 继承，经典类不需要。新式类的MRO(method resolution order 基类搜索顺序)算法采用C3算法搜索，经典类的MRO算法是采用深度优先搜索。 在 python3 统一采用新式类。]]></content>
      <categories>
        <category>Python</category>
        <category>笔试面试题</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>刷题</tag>
        <tag>笔试面试</tag>
      </tags>
  </entry>
</search>
