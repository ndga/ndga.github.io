<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NAT-SNAT-DNAT]]></title>
    <url>%2F2019%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FNAT-SNAT-DNAT%2F</url>
    <content type="text"><![CDATA[NATNAT：网络地址转换（Network Address Translation） 优点 节约公网的IP地址（费用） 能够有效地避免来自外网的攻击，隐藏并保护内网的计算机（外网的人不知道内网的IP地址） 缺点 数据会有延迟 IP地址 A类IP地址范围：1.0.0.1 — 126.255.255.254（127.0.0.1 为保留地址，一般用于本地环回地址） loopback：指本地环回接口（或地址），亦称回送地址 私有地址包括三类 A类：10.0.0.0~10.255.255.255 B类：172.16.0.0~172.31.255.255 C类：192.168.0.0~192.168.255.255 某台机器上配置的 ip 地址为 192.168.0.180，访问 127.0.0.1 的 80 端口和访问 192.168.0.180 的 80 端口有什么区别？ 127.0.0.1:80 只能允许本机去访问，其他机器访问不了 192.168.0.180:80 能被整个 192.168.0.0 网段或者路由能到达的机器访问 0.0.0.0到底什么意思？ 代表本机上有的所有 ip 地址（所有接口上配置的 ip 地址） Linux 内核里有个 NAT 映射表： 源ip：源端口 目的ip：目的端口 源mac地址 映射：即访问一个A 然后转到D去，如：A —&gt; DB —&gt; C有个一一对应的关系，有2边的阵容，访问一般的A，会给你转到另外一边的D。 SNATSNAT：源地址转换（Source Network Address Translation），修改数据包的源 IP 地址。 SNAT的作用 局域网多个主机共享单个公网IP地址接入互联网，让局域网的机器上网，局域网内全部使用私有网络IP地址，可节省公网的IP地址。 把局域网的IP地址转化成公网的IP地址去访问外网，这样返回的响应报文中目的地址会是找得到的公网IP地址，外面的人不知道局域网内的IP地址，起到隐藏内网的作用。 SNAT策略的应用 准备两台centos7的虚拟机一台充当内网主机，IP地址为192.168.57.1。一台充当NAT Server，内网接口的IP地址是192.168.57.2，外网接口的IP地址是192.168.0.156。 1. 配置两台主机的IP地址、子网掩码和默认网关地址 临时配置IP地址（重启失效）ip address add 192.168.57.1/24 dev ens33 配置ip地址ip add del 192.168.57.1/24 dev ens33 删除ip地址 永久配置IP地址、子网掩码和默认网关地址 123456789101112[root@MySQL network-scripts]# cat ifcfg-ens33# BOOTPROTO=dhcpBOOTPROTO=noneNAME=ens33# UUID=655909bd-e927-49a5-88f0-4aeb333409d4DEVICE=ens33ONBOOT=yesIPADDR=192.168.57.1PREFIX=24GATEWAY=192.168.57.2DNS1=114.114.114.114[root@MySQL network-scripts]# service network restart ifcfg-ens33是一个配置文件，Linux下一切皆文件，文件是放在磁盘里的，能被保存下来；而内存里的东西关机后不会被保存。 重新配置 ip 地址后（service network restart）的问题？ ifup ens33 就是去读取网卡配置文件里的 ip 地址，配置到电脑上 ifdown ens33 关闭网卡 service network restart 先关闭网卡，再去读取网卡配置文件里的 ip 地址，配置到电脑上service network restart =&gt; 先 ifdown ens33 再 ifup ens33 2. 清除两台主机的防火墙规则 centos7里默认的防火墙软件 firewallcentos6里默认的防火墙软件 iptables 清除防火墙规则systemctl stop firewalld 关闭firewalld服务iptables -F 清除filter表里的规则iptables -t nat -F 清除nat表里的规则 查看防火墙规则iptables -L 查看filter表里的规则iptables -t nat -L 查看nat表里的规则iptables -t nat -L -nv 以数字形式查看nat表的防火墙规则 3. 开启NAT_Server主机的路由转发功能 临时开启路由功能（重启失效，刷新网络服务也会导致路由功能关闭）echo 1 &gt;/proc/sys/net/ipv4/ip_forward 永久开启路由功能修改/etc/sysctl.conf文件 123[root@NAT_Server ~]# vim /etc/sysctl.conf[root@NAT_Server ~]# cat /etc/sysctl.confnet.ipv4.ip_forward=1 sysctl -p 让内核重新读取文件，配置开启路由功能 123[root@NAT_Server ~]# sysctl -p[root@NAT_Server ~]# cat /proc/sys/net/ipv4/ip_forward1 4. 添加使用SNAT策略的防火墙规则 规则示例iptables -t nat -A POSTROUTING -o ens37 -s 192.168.57.0/24 -j SNAT --to-source 192.168.0.156 解释iptables -t nat -A POSTROUTING 在nat表的POSTROUTING链上添加规则-o ens37 指定数据出去的接口为ens37（o：output）-s 192.168.57.0/24 指定来自特定网段 192.168.57.0/24 的数据包（s：source）-j SNAT 采取的 nat 措施是SNAT策略--to-source 192.168.0.156 指定接入公网时源IP地址改为192.168.0.156 5. 直接在防火墙的服务器编写配置NAT的脚本文件123456789101112131415[root@NAT_Server ~]# vim nat.sh[root@NAT_Server ~]# cat nat.sh #!/bin/bash# 清除nat和filter表里的防火墙规则iptables -t nat -Fiptables -F# 临时开启路由功能echo 1 &gt;/proc/sys/net/ipv4/ip_forward# 添加SNAT功能的防火墙规则iptables -t nat -A POSTROUTING -o ens37 -s 192.168.57.0/24 -j SNAT --to-source 192.168.0.156[root@NAT_Server ~]# bash nat.bash 6. 排除故障思路 检查ip地址、网关、dns是否正确 cat /etc/sysconfig/network-scripts/ifcfg-ens33 检查防火墙是否已关闭 iptables -L 检查路由器的路由功能是否已开启 cat /proc/sys/net/ipv4/ip_forward(0是关闭，1是开启) 检查snat策略是否已启用 iptables -t nat -L -nv 检查路由器本身是否可以上网 ping www.baidu.com 查看正在使用的ip地址 ip add或者ifconfig 查看配置的路由 ip route 查看真正使用的dns服务器地址 cat /etc/resolv.conf 临时关闭NetworkManager systemctl stop NetworkManager 如果有想开机自动执行的命令可以放到 /etc/rc.local 文件下 DNATDNAT：目标地址转换（Destinatvion Network Address Translation），修改数据包的目标IP地址 DNAT的作用 在公网上发布位于局域网内的服务器，把局域网的IP地址转换成公网上能找到的公网IP地址，让公网的用户可以直接访问。 外面的人不知道内网的服务器的IP地址，保护服务器免受黑客攻击 DNAT策略的应用-发布内网的Linux服务器 前提两台主机都配置好了IP地址、关闭了防火墙功能，NAT_Server主机已开启了路由转发功能，如果没有参考前面实现 1. 内网主机开启web服务器 安装epel源 yum install epel-release 安装web服务器-nginx软件包 yum install nginx 刷新nginx服务 service nginx restart 2. 查看服务是否开启 查看nginx服务是否开启 netstat -anplut|grep nginx 安装lsof软件包 yum install lsof查看80端口被哪个进程占用 lsof -i:80 3. 解决访问防火墙服务器本身的问题 方法一：修改ssh服务器的端口，把ssh服务的端口号改成其他的端口号vim /etc/ssh/sshd_config 方法二：修改DNAT策略iptables -t nat -A PREROUTING -i ens37 -d 192.168.0.156 -p tcp --dport 9988 -j DNAT --to-destination 192.168.57.1:22 4. 添加使用DNAT策略的防火墙规则 规则示例iptables -t nat -A PREROUTING -i ens37 -d 192.168.0.156 -p tcp --dport 80 -j DNAT --to-destination 192.168.57.1:80 解释iptables -t nat -A PREROUTING 在nat表的PREROUTING链上添加规则-i ens37 指定数据进来的接口为ens37（i：input）-d 192.168.0.156 指定访问的目的地址是外网ip为192.168.0.156（d：destination）-p tcp --dport 80 指定访问的端口是80端口，在传输层使用的协议是tcp协议（p：protocol）-j DNAT 采取的nat措施是DNAT策略--to-destination 192.168.57.1:80 指定转发到内网的目的IP是192.168.57.1并且端口也是80（端口号也是可以变的，不用跟外网的端口号对应，可以是别的端口号） 5. 直接在服务器上编写配置NAT的脚本文件123456789101112131415161718192021[root@MySQL ~]# vim nat.sh[root@MySQL ~]# cat nat.sh #!/bin/bash# 清除nat和filter表里的防火墙规则iptables -t nat -Fiptables -F# 临时开启路由功能echo 1 &gt;/proc/sys/net/ipv4/ip_forward# 添加SNAT功能的防火墙规则iptables -t nat -A POSTROUTING -o ens37 -s 192.168.57.0/24 -j SNAT --to-source 192.168.0.156# 添加web服务器的DNAT规则iptables -t nat -A PREROUTING -i ens37 -d 192.168.0.156 -p tcp --dport 80 -j DNAT --to-destination 192.168.57.1:80# 添加ssh服务器的DNAT规则iptables -t nat -A PREROUTING -i ens37 -d 192.168.0.156 -p tcp --dport 22 -j DNAT --to-destination 192.168.57.1:22[root@MySQL ~]# bash nat.bash DNAT策略成功后我们就可以通过访问192.168.0.156的IP地址访问到内网主机192.168.57.1的服务器 6. 一些常见服务的端口号 Web服务(nginx/apache)：80 SSH：22 MySQL：3306 SQLServer：1433 Oracle：1521 FTP：21 Tomcat：8080 Telnet ：23 HTTP：80 HTTPS：443]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>SNAT</tag>
        <tag>DNAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django-模型层-基本介绍]]></title>
    <url>%2F2019%2F08%2FDjango%2F%E6%A8%A1%E5%9E%8B%E5%B1%82%2FDjango-%E6%A8%A1%E5%9E%8B%E5%B1%82-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1. 使用db.conn的缺点 需要自己定义模块 每次都需要做连接 数据库迁移麻烦（Oracle迁移到MySQL） 2. ORMORM：对象关系映射（Object Relation Mapping） ORM 是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。ORM 主要实现程序对象到关系数据库数据的映射。优点： 方便数据库迁移 提高开发效率，不用专注于数据库及SQL 返回的数据格式很友好queryset[&lt;username=admin, password=1111&gt;, &lt;&gt;] 缺点： 性能没有原生语句好（本质上所有的ORM语句最终都是执行SQL） 灵活性较差，处理复杂查询时，ORM会很复杂 3. Model介绍 环境说明： * Django==1.11.20 * Python==3.7 1. 可连接不同数据库 支持的数据库&#39;django.db.backends.postgresql&#39;&#39;django.db.backends.mysql&#39;&#39;django.db.backends.sqlite3&#39;&#39;django.db.backends.oracle&#39; 如：在项目的settings.py文件中配置mysql 12345678910111213DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;filepath&apos;, &apos;USER&apos;: &apos;root&apos;, &apos;PASSWORD&apos;: &apos;xxx&apos;, &apos;HOST&apos;: &apos;xxx.xxx.xxx.xxx&apos;, &apos;PORT&apos;: &apos;3306&apos;, &apos;OPTIONS&apos;: &#123; &apos;init_command&apos;: &quot;SET sql_mode=&apos;STRICT_TRANS_TABLES&apos;&quot;, &#125;, &#125;&#125; 如：在项目的settings.py文件中配置sqlite3 123456DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.sqlite3&apos;, &apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;), &#125;&#125; 2. 字段命名的限制 字段的名称不能是Python保留的关键字。例如： 12pass = models.IntegerField() # 'pass' is a reserved word! 由于Django查询语法的工作方式，字段名称中连续的下划线不能超过一个。例如： 12foo__bar = models.IntegerField() # 'foo__bar' has two underscores! 这些限制有变通的方法，因为没有要求字段名称必须与数据库的列名匹配。参见 db_column 选项。SQL的保留字例如 join、where 和 select，可以用作模型的字段名，因为 Django 会对底层的 SQL 查询语句中的数据库表名和列名进行转义。它根据你的数据库引擎使用不同的引用语法。 3. 配置日志记录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# mysite/settings.py# 定义并创建目录LOG_PATH = os.path.join(BASE_DIR, 'log')if not os.path.exists(LOG_PATH): os.mkdir(LOG_PATH) LOGGING = &#123; 'version': 1, 'disable_existing_loggers': True, # formatters：配置日志格式 'formatters': &#123; 'standard': &#123; 'format': '%(asctime)s [%(threadName)s:%(thread)d] [%(name)s:%(lineno)d] [%(module)s:%(funcName)s] [%(levelname)s]- %(message)s' &#125;, # 对日志信息进行格式化，每个字段对应了日志格式中的一个字段，更多字段参考官网文档 'myformat':&#123; 'format': '%(asctime)s %(pathname)s - %(message)s' &#125; &#125;, # handlers： 配置日志记录到哪里 'handlers': &#123; 'default': &#123; 'level':'DEBUG', 'class':'logging.handlers.RotatingFileHandler', # 'filename': LOG_PATH+'/all.log', # 日志输出文件 'filename': os.path.join(LOG_PATH, 'all.log'), # 日志输出文件 'maxBytes': 1024*1024*5, # 文件大小 'backupCount': 5, # 备份份数 'formatter':'standard', # 使用哪种formatters日志格式 &#125;, 'app1': &#123; 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', 'filename': LOG_PATH + '/app1.log', # 日志输出文件 'maxBytes': 1024 * 1024 * 5, # 文件大小 'backupCount': 5, # 备份份数 'formatter': 'myformat', # 使用哪种formatters日志格式 &#125;, 'console':&#123; 'level': 'DEBUG', 'class': 'logging.StreamHandler', 'formatter': 'standard' &#125;, &#125;, # loggers: 定义记录器，供程序调用 'loggers': &#123; # 名为django的logger会自动记录，其他需要自己调用 'django': &#123; 'handlers': ['default','console'], 'level': 'DEBUG', 'propagate': True &#125; &#125;&#125; 4. 模型定义 每个模型都是django.db.models.Model的一个Python子类。 模型的每个属性都表示为数据库中的一个字段，即映射到一个数据库的列。 Django提供一套自动生成的用于数据库访问的API；详见执行查询。 官方文档 models.py 编写示例123456789101112131415161718192021from django.db import modelsfrom django.contrib.auth.models import User# Create your models here.# 分类表class Category(models.Model): # 定义字段 name = models.CharField(max_length=30, verbose_name="分类名称") desc = models.CharField(max_length=255, default=None, verbose_name="分类描述") index = models.IntegerField(default=999, verbose_name='分类的排序') # 设置元数据（设置查询和展示的输出） class Meta: verbose_name = '分类' verbose_name_plural = verbose_name ordering = ['index', 'id'] db_table = "category" # 类的魔术方法，返回一个友好的显示 def __str__(self): return self.name 5. 同步到数据库 在虚拟环境下执行同步命令 生成迁移文件（变更数据结构）python manage.py makemigrations 生成的迁移文件在该应用的 migrations 目录（以dddd_changecontext.py命名） 查看更新的SQL语句 python manage.py sqlmigrate appname 0001 应用迁移文件到数据库 python manage.py migrate 把迁移文件生成sql语句 在数据里面执行sql语句 在django_migrations表中记录哪些迁移文件被执行过。 注意：migrations 目录下的文件不能随意删除。通过测试发现，检测 Model 变化是与该目录下文件做对比，因此该目录下内容不能随意删除。 6. 数据备份-导入导出 导入：python manage.py loaddata data/initdata/xxx.json 导出：python manage.py dumpdata model_query &gt; data/initdata/mod el_query.json 7. 注意事项 表名这个表的名称AppName_ClassName，是根据模型中的元数据自动生成的，也可以重写为别的名称，详见Table names。 id 字段如果一个 Model 里面没有设置主键，Django 会自动增加一个名为 id 的自增型字段。但这个行为可以被重写。详见自增主键字段。Django的表里面不可以没有主键，但是可以不设置 id 为主键。 SQL语句来源Django 会根据设置文件中指定的数据库类型来使用相应的SQL语句 定义完模型字段后，只要对模型做了修改，都需要执行python manage.py makemigrations和python manage.py migrate 回滚 删除生成的表/字段 删除django_migrations表中对应的记录 删除迁移文件 建议：数据备份，不建议：删库操作]]></content>
      <categories>
        <category>Django</category>
        <category>模型层</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django-开发环境搭建]]></title>
    <url>%2F2019%2F07%2FDjango%2FDjango-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[在GitHub上创建一个仓库​ 登录 GitHub 后，点击 Repositories ，再点 new 新建仓库，如图配置： ​ 在 GitHub 上创建一个仓库，是为了后期可以把所有代码都上传到这个仓库里。Git是一个分布式版本控制工具，可以记录每次修改的文件及修改的内容，使用Git可以很好的给代码做备份，防止丢失，还能给出备份的时间节点以及不同备份间的区别，方便我们管理版本。当我们想查看某次改动的内容，只需要看提交的备注信息就能找到当时的提交文件，还可以进行回滚，获取当时的版本，适合多人协作。 Django-开发环境搭建1. 环境说明 Windows Python3.7 Django1.11.20 SQLLite PyCharm Git 2. 搭建流程 克隆远程仓库到本地仓库，进入 master 分支 $ git clone https://github.com/ndga/Django_study.git $ cd Django_study/ 进入本地仓库 $ git init 初始化本地仓库 （或者直接手动进入本地仓库文件夹里面，右击打开 Git Bash Here，进入 master 分支） 基于 master 分支新建一个分支并切换到新建的分支 $ git branch 列出本地分支 $ git branch -a 列出所有分支 方法一 $ git branch v0.1-django-start 创建v0.1-django-start分支 $ git checkout v0.1-django-start 切换到 v0.1-django-start 分支 方法二 $ git checkout -b v0.1-django-start 创建并切换到 v0.1-django-start 分支 在 v0.1-django-start 分支下配置好虚拟环境 $ python -V 查看 python 的版本 $ python -m venv venv 创建虚拟环境，名为 venv $ source venv/Scripts/activate 进入 venv/Scripts/ 文件夹下并启动虚拟环境 $ pip list 查看虚拟环境里的安装包，如果安装包只有这几个基本上是成功了 1234567891011李@DESKTOP-6SPHB1I MINGW64 /f/Django_study (v0.1-django-start)$ pip listPackage Version---------- -------pip 19.0.3setuptools 40.8.0You are using pip version 19.0.3, however version 19.1.1 is available.You should consider upgrading via the &apos;python -m pip install --upgrade pip&apos; command.(start_venv)李@DESKTOP-6SPHB1I MINGW64 /f/Django_study (v0.1-django-start)$ $ pip install django==1.11.20 安装 1.11.20 版本的 Django $ pip freeze &gt; requirements.txt 把所有要安装的安装包写入到 requirements.txt 这个文件（这样别人要用的时候就知道该安装什么） $ deactivate 退出虚拟环境 修改 .gitignore 文件 .idea/ =&gt; 使用pycharm会生成的文件，push 到 GitHub 上时需要忽略 venv/ =&gt; 虚拟环境的文件，也需要忽略 把改动提交到仓库 $ git status 查看状态 $ git add requirements.txt 添加 requirements.txt 文件到暂存库 $ git add .gitignore 添加 .gitignore 文件到暂存库 $ git commit -m &#39;env init&#39; 将暂存库的内容提交到版本库，每次提交都必须将提交的注释加上 $ git push --set-upstream origin v0.1-django-start 第一次推送 v0.1-django-start 分支以及里面的内容到远程仓库，之后只要 git push 就可以了 已经把不需要的文件推送到远程仓库怎么办 先把需要忽略的文件移到另外一个文件（相当于给文件改个名字） $ mv filename1 /filename2 把 filename1 和 filename2 都加到 .gitignore 文件里 提交一次（$ git add .， $ git commit -m&#39;xx&#39;，$ git push） 再把文件移回来 mv /filename2 filename1 重新提交一次（$ git add .， $ git commit -m&#39;xx&#39;，$ git push） Django-项目与应用创建1. 常用命令 django-admin：常用来创建项目及应用 123456789101112131415161718192021222324252627Type &apos;django-admin help &lt;subcommand&gt;&apos; for help on a specific subcommand.Available subcommands:[django]checkcompilemessagescreatecachetabledbshelldiffsettingsdumpdataflushinspectdbloaddatamakemessagesmakemigrationsmigraterunserversendtestemailshellshowmigrationssqlflushsqlmigratesqlsequenceresetsquashmigrationsstartappstartprojecttesttestserver manage.py：常用来管理项目，如运行开发环境，数据库操作，用户操作等，python manage.py help查看帮助文档 12345678910111213141516171819202122232425262728293031323334353637Type &apos;manage.py help &lt;subcommand&gt;&apos; for help on a specific subcommand.Available subcommands:[auth] changepassword createsuperuser[contenttypes] remove_stale_contenttypes[django] check compilemessages createcachetable dbshell diffsettings dumpdata flush inspectdb loaddata makemessages makemigrations migrate sendtestemail shell showmigrations sqlflush sqlmigrate sqlsequencereset squashmigrations startapp startproject test testserver[sessions] clearsessions[staticfiles] collectstatic findstatic runserver 2. 创建项目和应用 创建项目 $ django-admin startproject projectname 创建应用 $ cd projectname/ $ django-admin startapp appname 注意：每次只要新建了app应用，就要在settings.py文件中的INSTALL_APP里加上app的名字 用 PyCharm 打开项目（选择到项目根目录-mysite） 设置解释器为虚拟环境里的解释器（去虚拟环境的文件夹下找，选择到python.exe） 3. 目录结构12345678910111213141516171819Django_study |_.git # 配置、版本历史等等... |_.gitignore # 忽略某些文件（不检查这些文件的变化、不上传git仓库） |_README.md |_venv # 虚拟环境（文件夹名称随意），不加入git仓库 |_mysite # 项目名称 |_mysite | |_settings.py # 项目的配置文件 | |_urls.py # 编写路由，与视图映射 | |_wsgi.py # 接口文件，用来做部署，不需要修改 | |_... # 如（__init__.py：初始化文件） |_manage.py # 管理项目的文件 |_app1 # 应用名称 |_migrations # 迁移文件 |_admin.py # 后台文件，强大的超级管理员 |_apps.py # 应用的配置文件 |_models.py # 模型，配置与数据库相关的内容 |_tests.py # 写测试用例的文件 |_views.py # 视图，负责业务逻辑]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django-初认识]]></title>
    <url>%2F2019%2F07%2FDjango%2FDjango-%E5%88%9D%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Python Web框架介绍1. 什么是框架web 框架（web framework）是用于进行 web 开发应用的一套软件架构，有助于我们把程序的整体架构搭建好，基于 web 框架实现业务逻辑，减少了工作量，能够让我们专注于 web 应用上有趣的关键性逻辑 , web 框架能够在合适的时候调用我们写的逻辑, 而不需要我们自己去调用逻辑。 2. Web框架有哪些Django: 重量级的Web框架，功能丰富，灵活性差 Flask: 轻量级的Web框架，可扩展性强 Tornado: 轻量级的异步Web框架 Django介绍1. Django的历史 源自于一个在线新闻Web站点，于2005年以开源的形式被释放出来。 官网：https://www.djangoproject.com/ 2. Django的特点 主要目的是简便、快速地开发数据库驱动的网站 功能丰富：自带ORM、URL分发、模板系统、表单处理、Cache系统、会话管理、国际化、后台管理 可扩展：pypi及git上有很多基于Django开发的应用 3. Django的优势和劣势 Django优势 完美的文档 全套的解决方案 强大的URL路由配置 自助管理后台 Django劣势 系统紧耦合，灵活性差 请求响应流程1. MVC模式 模型(M)： 定义数据库相关的内容，负责业务对象与数据库的映射(ORM) 视图(V)： 定义HTML等静态网页文件相关，负责与用户的交互(页面) 控制器(C)： 定义业务逻辑相关，就是你的主要代码，负责接受用户的输入调用模型和视图完成用户的请求 2. Django的MTV模式 M 代表模型（Model）：负责业务对象和数据库的关系映射(ORM)（如何存取，如何验证有效性，包含哪些行为以及数据之间的关系等） T 代表模板 (Template)：负责如何把页面展示给用户(html) V 代表视图（View）：负责业务逻辑，并在适当时候调用Model和Template 3. MVC/MVT设计模式关键的优势 开发者更改一个应用程序中的 URL 而不用影响到这个程序底层的实现 设计师可以改变 HTML页面的样式而不用接触业务逻辑代码 数据库管理员可以重新命名数据表并且只需更改模型 4. 请求响应流程图（简版） 5. 请求响应流程图（复杂版） ​ 前面的图片展示了从一个访客的浏览器到Django应用并返回的一个web请求的简单历程。如下是数字标识的路径： 浏览器发送请求（基本上是字节类型的字符串）到web服务器 web服务器（比如，Nginx）把这个请求转交到一个WSGI（比如，uWSGI），或者直接地文件系统能够取出 一个文件（比如，一个CSS文件） 不像web服务器那样，WSGI服务器可以直接运行Python应用。请求生成一个被称为environ的Ptyhon字典， 而且，可以选择传递过去几个中间件的层，最终，达到Django应用 URLconf中含有属于应用的urls.py选择一个视图处理基于请求的URL的那个请求，这个请求就已经变成了 HttpRequest——一个Python字典对象 被选择的那个视图通常要做下面所列出的一件或者更多件事情： A. 通过模型与数据库对话 B. 使用模板渲染HTML或者任何格式化过的响应 C. 返回一个纯文本响应（不被显示的） D. 抛出一个异常 HttpResponse对象离开Django后，被渲染为一个字符串 在浏览器见到一个美化的，渲染后的web页面]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2019%2F06%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[1. 什么是HTTP协议？HTTP：超文本传输协议（Hyper Text Transfer Protocol）HTTP协议是用于从万维网（WWW：World Wide Web ）服务器传输超文本到本地浏览器的传送协议，规定了服务器和本地浏览器之间如何通信以及通信所使用的数据格式。服务器 –&gt; 超文本传输协议 –&gt; 浏览器（客户端，如：电脑、手机、平板）。HTTP通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 2. 什么是超文本(Hyper Text)？包含有超链接(Link)和各种多媒体元素标记(Markup)的文本。这些超文本文件彼此链接，形成网状(Web)，因此又被称为网页(Web Page)。这些链接使用URL表示。最常见的超文本格式是超文本标记语言HTML。 3. 什么是URL？URL：统一资源定位符（Uniform Resource Locator），用来唯一地标识万维网中的某一个文档。URL由三部分构成：协议、主机域名和端口、文件路径。如图： 4. HTTP协议属于哪层协议？应用层协议：HTTP、HTTPS、FTP、SMTP、SNMP 5. 哪些软件能读懂HTTP协议？提供Web服务的软件都能读懂HTTP协议； 常见的web服务器软件：nginx、apache、tomcat、IIS、django、flask等 常见浏览器：chrome、firefox、curl、requests等 6. HTTP协议采用什么结构？C/S结构（客户/服务器） 客户—Browser：请求、接收、展示Web对象 服务器—Web Server：响应客户的请求，发送对象 7. HTTP协议有哪两种报文？ 请求报文 –&gt; request，请求消息由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 响应报文 –&gt; response，响应消息由状态行、消息报头、空行和响应正文四个部分组成。 8. HTTP的连接方式和无状态性 非持久性连接（短连接） 浏览器每请求一个Web文档，就创建一个新的连接，当文档传输完毕后，连接就立刻被释放。如果请求的Web页中包含多个文档链接，请求每个链接对应的文档都要创建新连接，效率低下。HTTP1.0、HTTP0.9采用此连接方式。 持久性连接（长连接） 在一个连接中，可以进行多次文档的请求和响应。服务器在发送完响应后，并不立即释放连接，浏览器可以使用该连接继续请求其他文档。连接保持的时间可以由双方进行协商（keepalive_timeout：表示传送完最后一个响应之后的连接保持时间的一个参数）。HTTP1.1采用此连接方式。 无状态性 指同一个客户端第二次访问同一个Web服务器上的页面时，服务器无法知道这个客户曾经访问过。HTTP是无状态协议，协议本身并不会保存用户的任何信息，每次请求都是独立的（服务器不维护任何有关客户端过去所发请求的消息）。HTTP的无状态性简化了服务器的设计，可以减小服务器的压力，使其更容易支持大量并发的HTTP请求。 9. HTTP协议的版本比较，现在使用的是什么版本？ 版本 产生时间 内容 情况 HTTP0.9 1991年 不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求，非持久性连接(短连接) 没有作为正式的标准 HTTP1.0 1996年 传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令，非持久性连接(短连接) 正式作为标准 HTTP1.1 1997年 持久性连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码 用了比较久的时间，2015年之前使用的最广泛的版本 HTTP2.0 2015年 多路复用、服务器推送、消息头压缩、二进制格式等 比较新的版本 10. HTTP协议的 1.1 和 2.0 有什么区别？ 数据格式 HTTP 1.1采用的是文本格式。 HTTP 2.0采用的是二进制格式。 消息头压缩 HTTP 1.1不支持header数据的压缩。 HTTP 2.0使用HPACK算法对header的数据进行压缩，这样数据量小，网络传输时间相对短一些。 多路复用 HTTP 1.1默认是持久性连接，所以不用频繁地去创建连接，但是在连接中的多个请求还是会顺序处理，所以一旦有一个请求处理很久的话，后面的请求就会被阻塞。 HTTP 2.0解决了HTTP 1.1中长连接遇到阻塞的问题。它采用多路复用的方式，同一个连接可以并发处理多个请求，同时处理多个消息的请求和响应，而且并发请求的数量比HTTP 1.1大了好几个数量级。 11. 在浏览器里输入https://www.baidu.com ，一个回车后，浏览器里会显示百度的首页，请详细说下背后发生了什么，越细致越好？ 浏览器从URL中获取域名www.baidu.com （如果有端口号，将端口号也解析出来）； 把主机名解析成对应的 IP 地址 浏览器首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 IP 地址； 如果本地的 hosts 文件没有该域名对应的 IP 地址，浏览器会向本地DNS服务器发出查询请求（属于递归查询），本地DNS服务器会查询它的缓存记录，如果有直接返回结果。（如果是首次，由于没有DNS服务器的MAC地址，所以只需要将数据发送给网关路由器192.168.0.1（通过ARP获取其MAC地址），他会想办法发给DNS服务器） 如果本地DNS服务器没有该域名对应的 IP 地址，就需要它代替浏览器给它的上级服务器发送查询请求（属于迭代查询），直到本地DNS服务器得到 IP 地址，返回给浏览器。 浏览器得到 IP 地址后，与服务器通过Socket三次握手建立TCP连接(默认端口号443) 客户端首先向服务器发送一个带有SYN 标识和一个seq的随机数。 服务端收到后，需要给客户端回应一个ack，ack的值就是刚才的seq随机数的值+1，在回应包里，还包含一个SYN的标识和一个seq随机数。 客户端收到服务端发过来的回应包之后，再给服务端发送一个ack,ack的值就是刚才服务端发过来的seq的值+1，三次握手完成。 浏览器向服务器发起HTTP请求，请求百度首页 客户端发送请求头信息，请求内容，最后会发送一空白行，标示客户端请求完毕 服务器通过HTTP响应把首页文件发送给浏览器 浏览器与服务器四次挥手，关闭TCP连接 首先客户端会发送一个带有FIN标识和一个seq随机数。 服务端收到之后，会回应一个ack，ack的值等于刚才的seq的值+1。 发送之后，服务器会再发一个FIN包，这个包里面包含一个seq随机数和第二次返回到客户端的ack值。 客户端收到之后，回应一个ack，ack的值等于刚才的seq值+1，以上完成之后，服务器和客户端的四次挥手就完成了。 浏览器将首页文件进行渲染，将html代码呈现出图片和文字、声音、视频等特效，显示给用户。 12. DNS 递归查询和迭代查询的区别？DNS：域名系统（Domain Name System）域名解析服务器 客户机和本地域名服务器之间一般是递归查询。当客户机向本地域名服务器发出 DNS 查询请求后，不管本地域名服务器能不能解析，最后都是由本地域名服务器把得到的结果返回给客户机。（就好比小明向李老师问了一个问题，李老师告诉了他答案，这就是递归查询。） 本地域名服务器和其他域名服务器之间一般是迭代查询。如果本地域名服务器不能解析，它不会让客户机向其他域名服务器发出查询请求，而是自己代客户机向其他域名服务器发出查询请求。在本地域名服务器向根域名服务器发出查询请求时，如果根域名服务器也不能解析，这时根域名服务器不会代本地域名服务器向顶级域名服务器发出查询请求，而是把顶级域名服务器的 IP 地址返回给本地域名服务器，本地域名服务器再向顶级域名服务器发出查询请求，直到得出结果。（就好比李老师也不知道答案，然后李老师去找陈老师，但是陈老师也不会，就让李老师去问张老师，直到李老师问到了答案，然后李老师再告诉小明，在李老师问其他老师时就是迭代查询。） 13. HTTP协议有哪几种请求方法？根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。 序号 方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于GET请求，只不过返回的响应中没有具体的内容，可以在不返回整个响应内容的情况下获取消息报头。 3 POST 向指定的资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新资源的建立或已有资源的修改。 4 PUT 从客户端向服务器传送最新的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP 1.1协议中预留给能够将连接改为管道方式（把请求连接转换到透明的 TCP/IP 通道）的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能，返回服务器支持的 HTTP 方法。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 14. GET和POST的区别？来自W3school：http://www.w3school.com.cn/tags/html_ref_httpmethods.asp GET POST 后退按钮/刷新 无害。幂等操作，即使刷新也还是跟原来一样。 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。如果往数据库里插入了一条数据，刷新后可能会再次插入。 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 有限制。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 没有限制。所以POST传输的数据量更大。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是显示在 URL 中的，明文传输。在发送密码或其他敏感信息时绝不要使用 GET ！ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中，对用户是透明的。 速度 快。GET 无实体主体，数据都在 URL 中，所以只需要三次握手2个 RTT。 慢。POST 先发送头部信息，再发送数据，相当于三次握手2个 RTT 和发送数据（实体主体）的1个 RTT。 15. 一些常见的响应码/状态码（HTTP Status Code）HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。完整的响应码可以查看原文：https://www.runoob.com/http/http-status-codes.html，HTTP状态码共分为5种类型： 1**：信息，服务器收到请求，需要请求者继续执行操作 100：Continue，继续。客户端应继续其请求。 101：Switching Protocols，切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，如切换到HTTP的新版本协议。 2**：成功，操作被成功接收并处理 200：OK，访问成功。服务器正常响应了请求。 201：Created，已创建。成功请求并创建了新的资源。 202：Accepted，已接收。已经接受请求，但未处理完。 3**：重定向，需要进一步的操作以完成请求 301：Moved Permanently，永久移动。网页位置发生变化。 302：Found，临时移动。资源只是临时被移动，还是在原来的网页位置。 304：Not Modified，网页没刷新 –&gt; 按Ctrl+F5，强制刷新网页内容（不从缓存里读取网页内容）。 4**：客户端错误，请求包含语法错误或无法完成请求 400：Bad Request，客户端请求的语法错误，服务器无法理解。 403：Forbidden，服务器理解客户端的请求，但是设置了权限，拒绝了用户的访问请求。 404：Not Found，网页不存在。 5** 服务器的内部问题，服务器在处理请求的过程中发生了错误 500：Internal Server Error，服务器内部错误，无法完成请求。 501：Not Implemented，服务器不支持请求的功能，无法完成请求。 502：Bad Gateway，网关错误，充当网关或代理的服务器在尝试执行请求时，从远程服务器接收到了一个无效的响应。 504：Gateway Time-out，充当网关或代理的服务器，未及时从远端服务器获取请求。 505：HTTP Version not supported，服务器不支持请求的HTTP协议的版本，无法完成处理。 16. HTTP协议和HTTPS协议的区别？ HTTP协议 HTTPS协议 默认端口 80 443 信息传输方式 超文本传输协议，信明文传输 SSL加密的超文本传输协议，密文传输 安全性 运行在TCP之上的HTTP协议 运行在 SSL/TLS 之上的HTTP协议，是可进行加密传输、身份认证的网络协议， 比HTTP协议更安全 17. HTTPS协议的实现原理（加密原理）？ 客户端向服务器发送HTTPS请求，就是用户在浏览器里输入一个https网址，然后连接到服务器的443端口。 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对非对称密钥（公钥和私钥），服务器把公钥返回给客户端，私钥自己保留。 服务器传送证书给客户端，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。 客户端得到证书后解析证书，这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值（随机的密钥）。客户端用证书对该随机值进行加密，即通过公钥对密钥加密（非对称加密）。 客户端传送用证书加密后的密钥给服务器，服务器收到密钥，用自己的私钥对其进行解密拿到对称密钥，再用对称密钥解密拿到数据，以后客户端和服务器的通信就可以通过这个随机值来进行加密解密（随机值用的是对称加密）。加密的数据只有客户端和服务器才能得到明文，即使第三方拿到了加密后的数据，因为没有私钥，也无法获取到真实的数据。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>网络知识</tag>
        <tag>http协议</tag>
        <tag>nginx配置</tag>
        <tag>抓包工具的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周刷题-20190320]]></title>
    <url>%2F2019%2F06%2FPython%2F%E6%AF%8F%E5%91%A8%E5%88%B7%E9%A2%98-20190320%2F</url>
    <content type="text"><![CDATA[1. Python和Java、PHP、C、C#、C++等其他语言的对比？​ C、C++、C# 都是编译性语言，必须编译后才能执行，而Python是一门解释型的动态类型的语言。在Python中，对象是通过引用传递的，编写代码时不需要声明变量类型，直接给变量赋值即可。Python是一边编译一边执行的，所以相较于C语言和Java来说运行速度会比较慢，但肉眼几乎感知不到，而且Python的语法非常简洁，大大提高编写效率。Python本身就是由C语言开发出来的，而且是开源的。PHP语言主要适用于网页编辑，而Python适合与各个领域。 Java：具有卓越的通用性、高效性、平台移植性和安全性，容易学，学精难，工具丰富 ，大多数人在用。缺点：运行速度相对于C/C++有些缓慢了，这是机制原因导致的。适用于网页、企业级开发、普通应用软件、游戏后台。 PHP：跨平台，性能优越；语法简单，入门快；目前主流技术都支持；有比较完整的支持；有很多成熟的框架；PHP 5已经有成熟的面向对象体系，能够适应基本的面向对象要求；有成熟的社区来支持PHP的开发；目前已经很多大型应用都是使用PHP；有很多开源的框架或开源的系统可以使用；配置及部署相对简单一些。缺点：多线程支持不太好，大多数时候我们只能简单的模拟去实现的；对语法不太严谨；PHP的解释运行机制繁琐。适用于网络前端，用于生成网页。也可以整个web服务器都用php，比如很多论坛引擎。 C：简洁紧凑、灵活方便；运算符丰富；数据类型丰富；表达方式灵活实用；允许直接访问物理地址，对硬件进行操作；生成目标代码质量高，程序执行效率高；可移植性好；表达力强；缺点：C语言的缺点主要表现在数据的封装性上，这一点使得C在数据的安全性上有很大缺陷，这也是C和C++的一大区别。还有运算符和运算优先级过多，不便于记忆，语法定义不严格，编程自由度大，对新手不太友好。适用于系统底层, 驱动, 嵌入式开发。 C#：用C# 开发应用软件可以大大缩短开发周期，同时可以利用原来除用户界面代码之外的C++代码，相比java，有更先进的语法体系、强大的周边。缺点：没有考虑代码量。 C++：可扩展性、高效简洁快速、可移植性、面向对象的特性、强大而灵活的表达能力和不输于C的效率、支持硬件开发、程序模块间的关系更为简单，程序模块的独立性、数据的安全性就有了良好的保障、通过继承与多态性，可以大大提高程序的可重用性，使得软件的开发和维护都更为方便，适用于游戏开发, 大规模, 高性能, 分布式要求的程序开发。 Python的特点： √优雅、明确、简单√解释型语言√开发效率非常高√高级语言√可移植性√可扩展性√可嵌入性 Python的不足之处： √运行速度慢√代码不能加密√多线程不能利用多CPU问题 2. 简述解释型和编译型编程语言​ 计算机是不能理解高级语言的，更不能直接执行高级语言，它只能理解机器语言，所以任何使用高级语言编写的程序若想被计算机运行，都必须将其转换成计算机语言。从而产生了两种转换方式：解释和编译，所以高级语言也分为了解释型语言和编译型语言。 （1）解释型语言的源代码不是直接翻译成机器语言，而是先翻译成中间代码，在程序运行的时候再由解释器把中间代码翻译成机器语言，解释型语言每执行一次就要翻译一次，效率比较低。比如Python、JavaScript、Perl、Shell等。 ​ （2）编译型语言在程序运行之前需要一个专门的编译过程，把源代码编译成机器语言的文件，等程序运行时，不需要重新翻译，不管运行多少次，都可以直接使用编译的结果，程序执行效率高，但依赖编译器，跨平台性差些。比如C、C++、Delphi等。 3. 代码中要修改不可变数据会出现什么问题，抛出什么异常？​ 报错，抛出TypeError异常。不可变数据类型包括 int、float、string(字符串)、tuple(元组)。可变数据类型包括 list(列表)、dict(字典)、set(集合)。 4. print 调用 Python 中底层的什么方法？​ 在 python2 中，print 是一个命令；在 python3 中，print 是一个函数，print() 调用 sys.stdout.write() 实现，往控制台打印字符串。但是 print() 跟 sys.stdout.write() 还是有点区别，print() 能自动换行，sys.stdout.write() 不能自动换行。print() 能接收多个参数输出，sys.stdout.write() 只能接收一个参数。另外，sys.stdout.write() 只接收字符串格式的参数。 123456789# python2中，两种方式print 'hello world'# hello worldprint('hello world')# hello world# python3中，一种方式print('hello world')# hello world 5. 简述你对 input() 函数的理解 在 python3 中，是内建函数，不需要导入。input(xxx)，输入的内容 xxx 会显示出来，而且 input() 接收的所有数据都是字符串类型。 在 python2 中，分为 input() 和 raw_input()，input() 接收 int（整型）类型的数据；raw_input() 接收 str（字符串）类型的数据。 6. Python解释器种类以及特点 CPython：用 C 语言开发的，是使用最广的 Python 解释器，在命令行下运行 Python 就是启动 CPython 解释器； IPython：基于 CPython 之上的一个交互式解释器，相较于 CPython，只是在交互方式上有所增强； Jpython：运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行； PyPy：用 Python 开发的，对 Python 代码进行动态编译（注意不是解释），所以可以显著提高 Python 代码的执行速度； IronPython：用 C# 开发的，是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码； 7. Python2 中 range 和 xrange 的区别​ 两者用法大致相同，不同的是 range 返回的结果是一个列表，而 xrange 返回的结果是一个生成器。range 是直接开辟一块内存空间来存放列表，xrange 不会直接生成一个列表来占用内存空间，而是在被调用的时候才返回其中的值，是惰性求值。所以当一个列表很大时，用 xrange 可以减少服务器的压力，xrange 性能比 range 好。 12345678&gt;&gt;&gt; print(type(range(10)))&lt;type 'list'&gt;&gt;&gt;&gt; print(type(xrange(10)))&lt;type 'xrange'&gt;&gt;&gt;&gt; print(range(10))[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; print(xrange(10))xrange(10) 8. 位和字节的关系？ 8 位（bit）= 1 字节（Byte） 位 (b) =&gt; 二进制位（0 或 1），是最小数据单位。 字节 (B) =&gt; 存储空间的基本计量单位，基本上1byte 存1个英文字母，2个byte存一个汉字。 9. b、B、KB、MB、GB 的关系？ 1 GB = 1024 MB 1 MB = 1024 KB 1 KB = 1024 B 1 B = 8 bit 10. 请至少列举5个 PEP8 规范（越多越好） 缩进：使用4个空格的缩进，不要使用制表符（Tab键），禁止空格与Tab键混用。 换行：折行以确保其不会超过79个字符。这有助于小显示器用户阅读，也可以让大显示器能并排显示几个代码文件。 空行：使用空行分隔函数和类，以及函数内的大块代码。顶级函数间空2行，类的方法之间空1行，同一函数内的逻辑块之间空1行，文件结尾空一行。 注释：如果可能，注释独占一行。避免逐行添加注释，避免没有一个注释。 空格：运算符周围和逗号后面使用空格，但是括号里侧不加空格，如：a = f(1, 2) + g(3, 4)。 导入格式：每个导入独占一行，导入放在文件顶部，位于模块注释和文档字符串之后，模块全局变量和常量之前。导入应该按照从最通用到最不通用的顺序分组（标准库 -&gt; 第三方库 -&gt; 自定义库），每种分组中, 应该根据每个模块的完整包路径按字典序排序，忽略大小写。不要使用 from xxx import * 这种语法。 变量命名：尽可能的使用有意义的变量名，词能达意。下划线命名法和驼峰命名法。包名、模块名、函数名、方法、普通变量名全部使用小写，单词间用下划线连接。类名、异常名使用 首字母大写（CapWords ） 的方式, 异常名结尾加 Error 或 Wraning 后缀。自定义的变量名、函数名不能和标准库中的函数名重名。 私有变量：小写和一个前导下划线（如：_value）。 内置变量：小写，两个前导下划线和两个后置下划线（如：init）。 11. python递归的最大层数？递归函数停止的条件？​ 可以通过 sys.setrecursionlimit() 进行设置，但是一般默认不会超过3925-3929这个范围。递归函数停止的条件一般定义在递归函数内部，在递归调用前要做一个条件判断，根据判断的结果选择是继续调用自身，还是 return 返回，停止递归。递归函数停止的条件： 判断递归的次数是否达到某一限定值 判断运算的结果是否达到某个范围等，根据设计的目的来选择 12. ASCII、GBK、Unicode、UTF-8的区别？ ASCII：计算机来源于美国，在计算机内部，所有信息最终都表示为二进制的字符串。每一个二进制位(bit)只有0和1两种状态，将8个二进制位看作一组，也就是一个字节(8bit=1byte)。8个二进制位可以组合出256种状态，即一个字节能够表示 256 个数字，数据范围是 0-255。ASCII码一共规定了128个字符的编码，一个字节代表一个字符，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。它的范围基本只有英文字母、数字和一些特殊符号 。 GBK：随着计算机在世界各地的普及，并且不是所有国家都使用英文，中国为了用字节编码汉字，就产生了GB2312。GB2312是对ASCII码的中文扩展，而GBK编码是对GB2312的扩展，完全兼容GB2312，GBK全称《汉字内码扩展规范》，使用双字节码。 Unicode：又称万国码，将世界上所有的符号都纳入其中，每一种符号都给予独一无二的编码，防止乱码。当时很多国家都弄了自己的一套编码标准，结果互相看不懂，有时候因为一个程序就要装一个编码系统，所以为了解决这个问题，就产生了Unicode，统一标准。 UTF-8：变长码，UTF-8是在互联网中使用最多的对Unicode的实现方式。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 13. 字节码和机器码的区别？ 字节码：一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码。 机器码：是计算机可以直接执行，并且执行速度最快的代码。 14. 三元运算规则以及应用场景？​ 三元运算符就是在给变量赋值的时候，可以直接加判断，然后赋值。三元运算符的功能与 if…else 流程语句一致，它在一行中书写，代码非常精炼，执行效率更高。 语法格式：变量 = 值1 if 条件表达式 else 值2（当条件表达式为True时，返回结果为值1，否则返回结果为值2，如：c = a if a &lt; b else b） 15. 列举 Python2和Python3的区别？ print 语句 在 python2 中，print 是一个命令语句，不论想输出什么，直接放到 print 关键字后面即可，如：print “内容”。 在 python3 中，print() 是一个函数，像其他函数一样，print() 需要你将要输出的东西作为参数传给它，如：print(“内容”)。 Unicode 字符串 在 python2 中，默认使用 ASCII 编码，导致字符串有两种类型，Unicode 字符串和非 Unicode 字符串。 在 python3 中，默认使用 Unicode 编码，所以只有一种类型，即 Unicode 字符串。 input 语句 在 python2 中，分为 input() 和 raw_input()，input() 接收 int 型(整型)的数据，raw_input() 接收 str 型(字符串类型)的数据。 在 python3 中，input() 是内建函数，不需要导入，input() 接收的所有数据都会变成字符串类型。 整型 在 python2 中，区分整型、长整型。 整型(int)：在32位机器上，整数的位数为32位，取值范围为-2^312^31-1，即-21474836482147483647。在64位系统上，整数的位数为64位，取值范围为-2^632^63-1，即-92233720368547758089223372036854775807。 长整型(long)：跟C语言不同，python的长整数没有指定位宽，即python没有限制长整数数值的大小，但实际上由于机器内存有限，我们使用的长整数数值不可能无限大。自从python2.2起，如果整数发生溢出，python会自动将整数数据转换为长整数，所以如今在长整数数据后面不加字母L也不会导致严重后果了。 在 python3 中，统称为整型(int)，可存超长数据。 整除 在 python2 中，键入的任何不带小数的数字，将被视为整数的编程类型，如：5/2=2，解决方法：5.0/2.0=2.5。 在 python3 中，整数除法变得更直观，5/2=2.5。 xrange 在 python2 中，range 函数生成的是一个列表，xrange 函数生成的是一个生成器。 在 python3 中，range 函数生成的是一个可迭代对象，并且不再有 xrange 函数存在，使用 xrange 会抛出命名异常。 类 在 python2 中，存在经典类和新式类的区别。新式类要求都从 object 继承，经典类不需要。新式类的MRO(method resolution order 基类搜索顺序)算法采用C3算法搜索，经典类的MRO算法是采用深度优先搜索。 在 python3 统一采用新式类。]]></content>
      <categories>
        <category>Python</category>
        <category>笔试面试题</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>刷题</tag>
        <tag>笔试面试</tag>
      </tags>
  </entry>
</search>
